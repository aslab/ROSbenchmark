%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,spanish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsspanish{\renewcommand{\contentsname}{Índice}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}


\usepackage{pdfpages}
\usepackage{afterpage}
\newcommand\blankpage{%
    \null
    \thispagestyle{empty}%
    \newpage}
\makeatletter

   \fancypagestyle{normal}{
    \fancyhf{}
    \fancyfoot[RO]{{\py@HeaderFamily \thepage}}
    \fancyfoot[LO]{{\py@HeaderFamily Carlos Castillo Martínez}}
    \fancyhead[RO]{{\py@HeaderFamily \@title\sphinxheadercomma\py@release}}
    \if@twoside
     \fancyfoot[LE]{{\py@HeaderFamily\thepage}}
     \fancyfoot[RE]{{\py@HeaderFamily Escuela Técnica Superior de Ingenieros Industriales (UPM)}}
     \fancyhead[LE]{{\py@HeaderFamily \nouppercase{\leftmark}}}
    \fi
    \renewcommand{\headrulewidth}{0.4pt}
    \renewcommand{\footrulewidth}{0.4pt}
    % define chaptermark with \@chappos when \@chappos is available for Japanese
    \ltx@ifundefined{@chappos}{}
      {\def\chaptermark##1{\markboth{\@chapapp\space\thechapter\space\@chappos\space ##1}{}}}

    }
\makeatother


\title{Estudio del comportamiento de micro-ROS. Un análisis teórico y práctico}
\date{07 de noviembre de 2021}
\release{}
\author{Carlos Castillo Martínez}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{ets_industriales.png}\par}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}

\newpage
\thispagestyle{empty}
\includepdf{Portada_TFG_CCM2.pdf}

\newpage
\thispagestyle{empty}


\begin{flushright} % Se alinea el texto en el lado derecho de la página.
\vspace*{5cm} % Se añade un espacio vertical de 5cm para situar la cita en ~1/3 de la página.

\textit{“If I have seen further it is by standing on the shoulders of Giants”} 

\medskip % Salto a la línea de tamaño medio (existen \smallskip, \medskip y \bigskip)
- Sir Isaac Newton

\end{flushright}

\afterpage{\blankpage} % Se añade una página en blanco después de la cita.

% Se comienza una página nueva con formato plano (sin encabezado/pie de página pero con número de página):
\newpage
\thispagestyle{empty}

\section*{Agradecimientos} % Se añade un asterisco a \section para que el título no esté numerado.
% \addcontentsline{toc}{chapter}{Agradecimientos} % Al utilizar \section* se ha de añadir manualmente el apartado al índice (Table Of Contents, TOC).

En primer lugar quería agradecer a mi familia el haber sido un apoyo incondicional para mí en todo momento por celebrar mis éxitos como si de los suyos se tratara y por evitar que me hundiese en los momentos más difíciles.

Le doy las gracias a mi tutor, Ricardo Sanz, por haberme brindado la oportunidad de realizar este proyecto y aprender de él. También quería agradecer a la doctoranda Esther Aguado su disponibilidad y ayuda durante todo el trabajo, fundamentales para el desarrollo del mismo. 

Por último, quisiera recordar a todos mis amigos y compañeros que me han acompañado en este largo viaje los últimos años. Sin ellos hubiera sido imposible llegar hasta este punto.

Quiero dedicar este trabajo especialmente a mis padres, por ser mis principales referentes en todo aquello que quiero llegar a ser en mi vida, tanto personal como profesionalmente.

\afterpage{\blankpage}

\newpage
\thispagestyle{empty}
\section*{Glosario}
\markright{Glosario}

% \addcontentsline{toc}{chapter}{Glosario}

- \textbf{ROS}: Sistema operativo de robots

- \textbf{IoT}: Internet de las cosas

- \textbf{RTOS}: Sistema operativo en tiemo real

- \textbf{Framework}: Entorno de trabajo

- \textbf{Firmware}: Programa que controla los circuitos electrónicos de un dispositivo

- \textbf{Middleware}: Software intermedio entre dispositivos y plataformas de software

- \textbf{Throughput}: Tasa de transferencia efectiva

- \textbf{Topic}: Tópico del mensaje

- \textbf{Publisher}: Editor de un topic

- \textbf{Subscriber}: Suscriptor de un topic

- \textbf{API}: Interfaz de programación de aplicaciones

- \textbf{DDS}: Servicio de distribución de datos

- \textbf{XRCE}: Entorno de recursos extremadamente limitados

- \textbf{UDP}: Protocolo de datagrama de usuario

- \textbf{TCP}: Protocolo de control de transmisión

- \textbf{POSIX}: Interfaz de sistema operativo portable

- \textbf{OTT}: Servicios de libre transmisión

- \textbf{UART}: Transmisor-Receptor Asíncrono Universal

- \textbf{MIMO}: Múltiple entrada, múltiple salida

\afterpage{\blankpage}

\newpage
\thispagestyle{plain}
\section*{Resumen Ejecutivo} % Se añade un asterisco a \section para que el título no esté numerado.
\markright{Resumen Ejecutivo} % Al utilizar \section* se ha de añadir manualmente el título del apartado al encabezado.

\addcontentsline{toc}{chapter}{Resumen Ejecutivo} % Al utilizar \section* se ha de añadir manualmente el apartado al índice (Table Of Contents, TOC).

Durante los últimos años, la tecnología ha ido creciendo a una velocidad exponencial en relación a etapas anteriores. Este hecho se traduce en la irrupción de la ya actual cuarta revolución industrial, también denominada industria 4.0.

Este fenómeno viene marcado por la aparición de nuevas tecnologías que están relacionadas con el tratamiento masivo de datos o “big data” y el Internet de las cosas (IoT).

Este último concepto se refiere a una interconexión digital de objetos cotidianos con Internet, lo cual genera un ecosistema de dispositivos inteligentes habilitados para recoger, enviar y actuar sobre los datos que adquieren de sus entornos.

En este sentido, la robótica constituye un sector fundamental en esta novedosa tecnología, que aprovecha y potencia las posibilidades que los robots ofrecen. Asimismo, los sistemas embebidos juegan un papel clave en la creación de estos ecosistemas, ya que permiten implementarse de manera sencilla en una gran cantidad de objetos cotidianos a un reducido coste, manteniendo unas prestaciones más que suficientes para las tareas que van a acometer.

Esto ha producido que el mundo de la robótica acelere su desarrollo a pasos agigantados en la última década, tanto a nivel de hardware como de software.

ROS es una tecnología pionera en el control de robots en tiempo real. Su crecimiento durante estos años está permitiendo a día de hoy la monitorización de muchos robots de una manera muy efectiva. Actualmente la versión en uso es ROS2. Sin embargo, recientemente se ha creado micro-ROS, una tecnología que acerca el mundo de ROS a los microcontroladores.

En este trabajo se va a estudiar el comportamiento de esta tecnología. En una primera etapa se analizará la base del funcionamiento de las comunicaciones en tiempo real. En este apartado se incluirán las restricciones que dichos sistemas requieren y las ventajas que pueden aportar.

Seguidamente se realizará un estudio teórico del funcionamiento de ROS. Esto incluye la base de programación que soporta ROS2, las distintas partes que forman la arquitectura del software y las herramientas que se utilizan para lograr integrar las funciones de ROS2 en microcontroladores.

Finalmente se plantearán una serie de análisis que simulen aplicaciones que se puedan dar en la vida real y se medirá el comportamiento que presenta micro-ROS instalado en una placa ESP-32.

Todo esto se realizará de manera autónoma sin ninguna experiencia previa en el sector, por lo que el trabajo resultante servirá también como guía de iniciación para la introducción a la programación del sistema operativo de robots.

Este trabajo ha sido realizado con Sphinx y LaTeX. Todo el código fuente empleado en el documento, tanto la memoria en LaTeX como la aplicación desarrollada, estarán disponibles en el repositorio https://github.com/aslab/ROSbenchmark.\\

\textbf{Codigos Unesco:}

120317 Informática

120323 Lenguajes de Programación

120324 Teoría de la Programación

120326 Simulación

\afterpage{\blankpage}


\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introducción}
\label{\detokenize{introduccion:introduccion}}\label{\detokenize{introduccion::doc}}

\section{Motivación}
\label{\detokenize{introduccion:motivacion}}
\sphinxAtStartPar
El motivo que ha predominado en la elección de este tema ha sido la
relación que mantiene con la tecnología del futuro. Resultaba muy interesante
el hecho adentrarse y contribuir en una tecnología en auge que puede marcar la diferencia
en los años venideros.

\sphinxAtStartPar
Por otra parte, enfrentarse a una tecnología tan sofisticada sin ningún conocimiento
previo suponía un reto. De este modo, este trabajo plasma las habilidades de resiliencia,
persistencia y duro trabajo que se han adquirido durante los últimos años.


\section{Objetivos}
\label{\detokenize{introduccion:objetivos}}
\sphinxAtStartPar
La principal finalidad de este trabajo es realizar un estudio completo
de ROS2 y micro\sphinxhyphen{}ROS, que comprenda desde el fundamento teórico e informático
que los soporta, hasta los análisis de comportamiento que presentan dichos
softwares frente a aplicaciones que simulan situaciones que se puedan dar en la vida real.

\sphinxAtStartPar
La idea del proyecto es iniciarse en una tecnología avanzada que se emplea
en ámbitos profesionales de la que se parte sin ningún conocimiento ni experiencia,
para que al final de este sea posible diseñar un experimento que muestre su comportamiento
frente a aplicaciones semejantes a las que se podrían dar en el mundo real. El motivo
de este estudio intensivo de dicha tecnología es ser capaces de indicar, no solo cómo
responde frente a distintas cargas de trabajo, sino también explicar el porqué de
dicho comportamiento desde un fundamento teórico que permita identificar
las posibles debilidades y puntos de mejora.


\section{Estructura}
\label{\detokenize{introduccion:estructura}}
\sphinxAtStartPar
El trabajo se divide en dos fases claramente diferenciadas.

\sphinxAtStartPar
La primera etapa está relacionada con la teoría que soporta todo el trabajo.

\sphinxAtStartPar
En el primer capítulo se exponen conceptos generales relacionados con
la comunicación de sistemas en tiempo real y se narran brevemente los inicios
de la tecnología que es sujeto de este estudio.

\sphinxAtStartPar
Una vez expuestos dichos conceptos, se explica con detalle
el software medido. Primero se desarrolla la base del funcionamiento de
ROS. Seguidamente, se
explican las especificaciones de ambos \sphinxstyleemphasis{frameworks}, incluyendo los conceptos
generales, la instalación, el requerimiento de otros tipos de software para
su uso y la arquitectura que los soporta.

\sphinxAtStartPar
Para concluir esta fase del trabajo, se finaliza explicando con gran
detalle todo el hardware que se ha empleado durante el proyecto, incluyendo
todas las especificaciones que puedan afectar a los resultados
del análisis.

\sphinxAtStartPar
La segunda parte está ligada con la práctica que se ha llevado a cabo.

\sphinxAtStartPar
En el primer capítulo de esta sección se expone detalladamente la forma
en la que se ha diseñado el análisis. Esto engloba los escenarios que se han
formado, los parámetros que se han escogido y las herramientas que se han
usado para realizar dichas mediciones.

\sphinxAtStartPar
Seguidamente se exponen en el capítulo posterior todos los resultados
que se han obtenido y una discusión de estos junto a las conclusiones
recogidas.

\sphinxAtStartPar
Después de discutir los resultados se han recogido en poco más de una cara
todas las conclusiones adquiridas durante todo el desarrollo del trabajo,
tanto relacionadas con la investigación llevada a cabo como con los resultados
de los análisis prácticos.

\sphinxAtStartPar
Para concluir con el trabajo se ha añadido un apartado de incidencias ocurridas
en el desarrollo del mismo, algo que podría resultar muy útil para futuras investigaciones.


\section{Metodología}
\label{\detokenize{introduccion:metodologia}}
\sphinxAtStartPar
La metodología empleada se caracteriza por ser principalmente autodidacta.

\sphinxAtStartPar
La tecnología que se ha analizado está sufriendo un desarrollo constante
en los últimos años, por lo que a día de hoy no existe la cantidad suficiente
de información para resolver todas las complicaciones que pueden emerger
al utilizarlo, sobre todo para un usuario no experimentado.

\sphinxAtStartPar
Esto se traduce en un trabajo en el que en algunos momentos ha sido necesario
recurrir y preguntar directamente a desarrolladores y consultar foros que
apenas llevaban creados pocos días.

\sphinxAtStartPar
En este sentido, el proyecto ha potenciado la capacidad de autosuficiencia
y de resolución de problemas del autor en situaciones en las que el entorno
no era el más favorable.


\chapter{Marco teórico y estado del arte}
\label{\detokenize{marco_teorico_y_estado_del_arte:marco-teorico-y-estado-del-arte}}\label{\detokenize{marco_teorico_y_estado_del_arte::doc}}

\section{Sistemas en tiempo real}
\label{\detokenize{marco_teorico_y_estado_del_arte:sistemas-en-tiempo-real}}
\sphinxAtStartPar
Se dice que un sistema opera en tiempo real cuando el tiempo que tarda
en efectuarse la salida es significativo. El tiempo de respuesta puede
ser relativamente flexible (tiempo real suave) o más estricto (tiempo
real duro), lo que se denomina software crítico. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id9}{36}{]}

\sphinxAtStartPar
La falta de respuesta en el tiempo establecido puede ocasionar graves
consecuencias para el entorno del sistema, llegando a producir daños a
la vida y a la propiedad.

\sphinxAtStartPar
Es por ello por lo que un sistema en tiempo real se diseña
específicamente para la tarea que ha de acometer, utilizando un hardware
y software dedicados.

\sphinxAtStartPar
El software empleado en sistemas de tiempo real cuenta con una serie de
características propias que garantizan el correcto funcionamiento del
sistema:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Sistema operativo en tiempo real: Los sistemas operativos en general
tienen dos principales funciones, gestionar bien los recursos que
proporciona el hardware y facilitar el uso del mismo al usuario. En
este caso, los objetivos del sistema operativo en tiempo real son los
mismos pero enfocados a las restricciones de tiempo y ocupar un
tamaño reducido para que pueda aplicarse a sistemas embebidos.

\item {} 
\sphinxAtStartPar
Lenguaje de programación en tiempo real: Proporciona esquemas básicos
como la comunicación y la sincronización entre tareas, el manejo de
errores y la programación de funciones a realizar en tiempo real. El
lenguaje C se ha utilizado ampliamente para este tipo de tareas
debido a su facilidad de uso e interacción con el hardware. Sin
embargo, otros lenguajes como Ada o Java se han desarrollado
específicamente para este tipo de uso y cada vez tienen más peso en
el sector.

\item {} 
\sphinxAtStartPar
Una red en tiempo real: Un sistema en tiempo real necesita una red
que sea puntual y fiable en la transferencia de mensajes, para ello
cuentan con un protocolo específico para trabajar en tiempo real que
proporciona una entrega puntual y garantizada de los mensajes a
través de la red.

\end{itemize}

\sphinxAtStartPar
Las características principales de los sistemas en tiempo real son las
siguientes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cumplimiento en los plazos de ejecución: Es lo que distingue a este
tipo de sistemas respecto al resto de sistemas informáticos.

\item {} 
\sphinxAtStartPar
Previsibilidad: Han de ser capaces de prever cualquier tipo de orden
que pueda ocurrir posteriormente para estar preparado y que no haya
fallos en los tiempos de ejecución.

\item {} 
\sphinxAtStartPar
Seguridad y fiabilidad: Muchos sistemas de este tipo se encargan de
controlar otros sistemas peligrosos en los que es de vital
importancia la precisión, ya no solo en el tiempo de la ejecución
sino en los movimientos del sistema.

\item {} 
\sphinxAtStartPar
Tolerancia a los fallos: Debido a la importancia del correcto
funcionamiento de estos sistemas, deben estar diseñados para que un
fallo en el propio hardware o software del mismo no repercuta
drásticamente en el resto de componentes y operaciones que ejecute el
sistema.

\item {} 
\sphinxAtStartPar
Concurrencia: El sistema tiene que ser capaz de cooperar con otros
sistemas que estén operando en el mismo entorno y, en determinadas
ocasiones, incluso utilizar el hardware o software de dichos
sistemas. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id8}{10}{]}

\end{itemize}


\subsection{Sistemas embebidos}
\label{\detokenize{marco_teorico_y_estado_del_arte:sistemas-embebidos}}
\sphinxAtStartPar
La mayoría de sistemas utilizados en tiempo real son sistemas embebidos.
Estos son aquellos en los que el computador se encuentra integrado en el
sistema. Se caracterizan por no ser sistemas informáticos generales que
se programan para distintas tareas, sino que están diseñados para
cumplir un objetivo en concreto. Generalmente, un sistema embebido está
constituido por un microcontrolador y una infraestructura diseñada para
el propósito para el que está diseñado. El microcontrolador está
constituido por una unidad central (CPU), que se encarga de realizar la
mayoría de procesos, una memoria, que almacena las instrucciones y otro
tipo de datos que aseguran el correcto funcionamiento del sistema; y un
subsistema de entrada y salida, que suele contar con temporizadores,
convertidores de señales analógicas y digitales, y canales de
comunicación en serie.


\subsection{Sistemas en tiempo real distribuido}
\label{\detokenize{marco_teorico_y_estado_del_arte:sistemas-en-tiempo-real-distribuido}}
\sphinxAtStartPar
Un sistema que trabaja en tiempo real distribuido está formado por unos
nodos autónomos que se comunican entre sí a través de una red que
trabaja en tiempo real y que cooperan para lograr unos objetivos comunes
en unos plazos determinados.

\sphinxAtStartPar
Estos sistemas son fundamentales debido a varias razones. En primer
lugar, la computación en tiempo real es esencialmente distribuida, ya
que se basa en la transferencia de información entre dos extremos
(nodos) a realizar en un tiempo determinado.

\sphinxAtStartPar
Seguidamente, la comunicación en tiempo real distribuido permite aislar
las partes del sistema e identificar fallos en el mismo evaluando los
nodos de la operación por separado. El cálculo realizado en cada nodo
debe cumplir con las restricciones de tiempo de las tareas, y la red
debe proporcionar un procesamiento en tiempo real con retrasos limitados
en los mensajes.

\sphinxAtStartPar
Además de esto, un equilibrio entre los distintos nodos del sistema
mejora el rendimiento del mismo.

\sphinxAtStartPar
Existen varios tipos de sistemas en tiempo real distribuido, sin
embargo, la arquitectura general de todos ellos es similar a la
figura que aparece a continuación.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{distributed_real-time_system_structure}.png}
\caption{Arquitectura general de un sistema en tiempo real distribuido (Fuente: Distributed Real\sphinxhyphen{}Time Systems, 2019)}\label{\detokenize{marco_teorico_y_estado_del_arte:id59}}\end{figure}

\sphinxAtStartPar
En la figura se observa cómo todos los nodos están conectados
entre sí a través de la red de tiempo real, y a su vez, cada uno está en
contacto con distintas funciones propias que interactúan directamente
con el sistema.


\section{ROS}
\label{\detokenize{marco_teorico_y_estado_del_arte:ros}}

\subsection{Definición}
\label{\detokenize{marco_teorico_y_estado_del_arte:definicion}}
\sphinxAtStartPar
El ROS o Robot Operating System (sistema operativo de robots), es una
colección de \sphinxstyleemphasis{frameworks} para el desarrollo de software de robots. Un
\sphinxstyleemphasis{framework} es un entorno de trabajo tecnológico que se basa en módulos
concretos que sirve de base para la organización y el desarrollo de
software. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id10}{38}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{ROS}.jpg}
\caption{Logotipo de ROS}\label{\detokenize{marco_teorico_y_estado_del_arte:id60}}\end{figure}

\sphinxAtStartPar
ROS no llega a ser considerado un sistema operativo como tal, ya que
necesita de un software de nivel superior para ser utilizado. Sin
embargo, ROS provee los servicios básicos de uno, como son la
abstracción del hardware, el control de dispositivos de bajo nivel, la
implementación de funcionalidad de uso común, el paso de mensajes entre
procesos y el mantenimiento de paquetes. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id11}{26}{]}

\sphinxAtStartPar
Está basado en una arquitectura de grafos, esto es, una estructura
formada por nodos, o extremos del sistema, y un conjunto de arcos que
establecen las relaciones entre dichos nodos. Estas relaciones se basan
en recibir, mandar y multiplexar mensajes de sensores, control,
periféricos, etc.

\sphinxAtStartPar
La librería está pensada y diseñada para ser utilizada en un sistema
operativo UNIX (base del actual Linux), sin embargo, también se están
lanzando versiones experimentales para otros sistemas operativos muy
comunes como Mac OS X o Microsoft Windows.

\sphinxAtStartPar
ROS se divide en dos partes básicas. Por un lado, actúa como nexo entre
el usuario y el hardware (más similar a un sistema operativo
convencional) y, por otra parte, se comporta como una batería de
paquetes desarrollados por una comunidad de usuarios. Estos paquetes
implementan numerosas funcionalidades como la localización y el mapeo
simultáneo, la planificación, la percepción, la simulación, etc.


\subsection{Historia}
\label{\detokenize{marco_teorico_y_estado_del_arte:historia}}
\sphinxAtStartPar
ROS se desarrolló en 2007 bajo el nombre de switchyard por el
Laboratorio de Inteligencia Artificial de Stanford para dar soporte al
proyecto del Robot con Inteligencia Artificial de Stanford (STAIR) y al
programa de robots personales (PR), en los cuales se crearon prototipos
internos de sistemas de software destinados a la robótica. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id12}{27}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=150\sphinxpxdimen]{{STAIR}.png}
\caption{Robot con Inteligencia Artificial de Stanford (Fuente: Stanford University)}\label{\detokenize{marco_teorico_y_estado_del_arte:id61}}\end{figure}

\sphinxAtStartPar
Desde 2008, el proyecto continuó principalmente en Willow Garage, un
instituto de investigación con más de veinte instituciones colaborando
en un modo de desarrollo federado, que proporcionó importantes recursos
para ampliar los conceptos ya creados y crear implementaciones sometidas
a varias pruebas.

\sphinxAtStartPar
El proyecto fue impulsado por una gran cantidad de investigadores con
mucha experiencia en el sector que aportaron numerosas ideas tanto al
núcleo central de ROS como al desarrollo de sus paquetes de software
fundamentales.

\sphinxAtStartPar
En un inicio, el software fue desarrollado utilizando la licencia de
código abierto BSD (Berkeley Software Distribution) y poco a poco se ha
convertido en una plataforma ampliamente utilizada en la comunidad de
investigación robótica.

\sphinxAtStartPar
Desde el principio, ROS ha sido desarrollado en múltiples instituciones
y para numerosos tipos de robots, incluidas aquellas que recibieron los
robots personales (PR2) directamente desde Willow Garage.

\sphinxAtStartPar
Cualquier persona puede iniciar su propio repositorio de código ROS en
sus propios servidores, y mantienen la plena propiedad y control del
mismo; además pueden poner su repositorio a disposición del público y
recibir el reconocimiento y el crédito que merecen por sus logros. De
esta forma también se fomenta la mejora del software ya existente con la
aportación de otros profesionales del sector.

\sphinxAtStartPar
Actualmente, el ecosistema de ROS cuenta con decenas de miles de usuarios
en todo el mundo, que trabajan en ámbitos que van desde proyectos
personales hasta grandes sistemas de automatización industrial.

\sphinxAtStartPar
Algunos de los robots que a día de hoy utilizan ROS son el robot
personal de Ken Salisbury en Stanford (PR1), el robot personal de Willow
Garage (PR2), el Baxter de Rethink Robotics, el Robot de Shadow, en el
cual participan universidades españolas, o el robot limpiador HERB de
Intel.


\subsection{Proyección futura}
\label{\detokenize{marco_teorico_y_estado_del_arte:proyeccion-futura}}
\sphinxAtStartPar
ROS ya cuenta hoy en día con una estructura
muy completa que proporciona al usuario múltiples posibilidades. Algunas
de las funcionalidades que engloba este software a día de hoy son la
creación, destrucción y correcta distribución de nodos en la red, la
publicación o suscripción de flujos de datos, la multiplexación de la
información, la modificación de los parámetros del servidor y el testeo
de sistemas.

\sphinxAtStartPar
A pesar de la gran cantidad de servicios que ya ofrece, se espera que en
futuras versiones se incorporen algunas de las siguientes
funcionalidades a las aplicaciones de ROS: identificación y seguimiento
de objetos, reconocimiento facial y de gestos, la comprensión del
movimiento, el agarre y la egomoción, entre muchas otras.

\sphinxAtStartPar
Como se ha podido comprobar, esta tecnología ha avanzado enormemente
durante los últimos años, y se prevé que este auge se maximice en el futuro próximo,
desempeñando un papel fundamental en la revolución de la
industria 4.0 y el fenómeno conocido como “el internet de las cosas”.
{[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id13}{29}{]}

\sphinxAtStartPar



\section{Micro\sphinxhyphen{}ROS}
\label{\detokenize{marco_teorico_y_estado_del_arte:micro-ros}}

\subsection{Definición}
\label{\detokenize{marco_teorico_y_estado_del_arte:id49}}
\sphinxAtStartPar
Micro\sphinxhyphen{}ROS es un \sphinxstyleemphasis{framework} que acerca las aplicaciones robóticas
diseñadas para infraestructuras de gran tamaño a dispositivos con
recursos limitados como son los microcontroladores. Este software lleva
la interfaz de programación de ROS a estos dispositivos y permite
integrarlos en los sistemas basados en ROS 2. La combinación entre ROS 2
y micro\sphinxhyphen{}ROS da como resultado un marco robótico que reduce las barreras
de entrada al mercado, reduciendo costes y acelerando el desarrollo de
robots.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{micro_ros}.jpeg}
\caption{Logotipo de micro\sphinxhyphen{}ROS}\label{\detokenize{marco_teorico_y_estado_del_arte:id62}}\end{figure}

\sphinxAtStartPar
La contribución de micro\sphinxhyphen{}ROS al mundo de la robótica va más allá. El
poder adaptar el sistema operativo de robots a sistemas embebidos
permite la interoperabilidad que exigen los sistemas robóticos
distribuidos para explotar la creciente superposición entre la robótica,
los dispositivos integrados y el IoT. De este modo, se simplifica la
construcción y el diseño de aplicaciones para sistemas robóticos de gran
tamaño, pudiendo dividirse estos en sistemas aislados más pequeños y
sencillos capaces de conectarse entre si, dotando al sistema general de
más información acerca del entorno, permitiendo que los sistemas
robóticos verdaderamente distribuidos interactúen de forma aún más
inteligente con el mundo que les rodea. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id17}{11}{]}


\subsection{Historia}
\label{\detokenize{marco_teorico_y_estado_del_arte:id51}}
\sphinxAtStartPar
Micro\sphinxhyphen{}ROS surgió a finales del año 2018, durante la celebración de
la «ROSCon», el evento más importante para la comunidad de ROS. Durante la conferencia
se habló sobre los beneficios que podría suponer la integración de ROS2 en los
microcontroladores. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id42}{23}{]}

\sphinxAtStartPar
Durante 2019, micro\sphinxhyphen{}ROS comenzó a utilizarse en los primeros RTOS. El primero
en incorporarlo en sus librerías fue NuttX, el cual desarrolló una serie de
aplicaciones de prueba en mayo de ese mismo año. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id44}{25}{]}

\sphinxAtStartPar
En 2020, micro\sphinxhyphen{}ROS continuó creciendo y realizando proyectos en común con
otros RTOS como FreeRTOS o Zephyr. Sin embargo, el mayor avance realizado
en ese año fue el desarrollo de nuevas versiones de Micro XRCE\sphinxhyphen{}DDS, el agente de
micro\sphinxhyphen{}ROS encargado de conectar el mundo de los microcontroladores con el espacio
de datos de ROS. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id45}{24}{]}

\sphinxAtStartPar
Ese mismo año se incluyó micro\sphinxhyphen{}ROS en la IDE de Arduino, un avance muy notable
ya que se trata de uno de los entornos de desarrollo más utilizados en lo que
a microcontroladores se refiere. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id46}{22}{]}

\sphinxAtStartPar
Durante este año se ha hecho realidad la noticia que afirma que micro\sphinxhyphen{}ROS se integrará
en el sistema operativo de Microsoft, el Microsoft Azure RTOS. El hecho de que micro\sphinxhyphen{}ROS
se haya incorporado en un software soportado por Microsoft le otorga una estabilidad
y un renombre que impulsará todavía más el desarrollo de esta tecnología. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id47}{17}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{microsoft_logo}.png}
\caption{Logotipo de microsoft}\label{\detokenize{marco_teorico_y_estado_del_arte:id63}}\end{figure}


\subsection{Proyección futura}
\label{\detokenize{marco_teorico_y_estado_del_arte:id57}}
\sphinxAtStartPar
Recientemente ha tenido lugar la conferencia de «ROS World 2021». En ella se han mostrado
los nuevos avances que tendrán lugar en el futuro cercano del universo de ROS. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id48}{32}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{rosworld2021}.png}
\caption{Logotipo de ROS World 2021}\label{\detokenize{marco_teorico_y_estado_del_arte:id64}}\end{figure}

\sphinxAtStartPar
En lo referido a micro\sphinxhyphen{}ROS, se ha anunciado una nueva librería del cliente y nuevas
funciones del middleware. En particular, se ha revelado el uso de la interfaz de Micro XRCE\sphinxhyphen{}DDS
para transportes personalizados, el paquete de diagnósticos de micro\sphinxhyphen{}ROS y el concepto de
trabajador para la gestión de la ejecución en la librería del cliente en C, rclc.

\sphinxAtStartPar
Además, se ha confirmado la posibilidad del desarrollo de aplicaciones profesionales
utilizando IDEs basados en Eclipse.

\sphinxAtStartPar
Estas noticias son muestras de que micro\sphinxhyphen{}ROS tiene un futuro muy prometedor por delante,
apoyado por una comunidad y un entorno muy favorables. La clave de esta previsión de
futuro es el esfuerzo que está realizando el mundo de ROS por acercar esta tecnología
a programadores inexpertos para ampliar en gran medida el alcance de la robótica.


\chapter{Software}
\label{\detokenize{software:software}}\label{\detokenize{software::doc}}
\sphinxAtStartPar
Como ya se ha comentado anteriormente, el foco principal de
este trabajo reside en analizar las características en tiempo
real de ROS2 y micro\sphinxhyphen{}ROS. Sin embargo, la comunicación entre estos
sistemas operativos y los sistemas reales requiere de la
participación de otros softwares intermedios o “middlewares”
que facilitan la comunicación con el mundo real.

\sphinxAtStartPar
En este capitulo se va a explicar el software empleado para
la realización del trabajo y la instalación del mismo.

\sphinxAtStartPar
La estructura del software empleada en el
análisis es la siguiente.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{estructura_software_editada}.png}
\caption{Comparación de la estructura de ROS 2 y micro\sphinxhyphen{}ROS (Fuente: freertos.org)}\label{\detokenize{software:id19}}\end{figure}


\section{ROS 2}
\label{\detokenize{software:ros-2}}
\sphinxAtStartPar
Desde que ROS comenzó en 2007, ha cambiado mucho la robótica y la propia
comunidad de ROS. Con el objetivo de adaptar esos cambios, recientemente
se ha lanzado una nueva versión de este software llamada ROS 2. Esta
recoge todo lo bueno que tenía ROS 1 y mejora aquello que se había
quedado algo obsoleto.

\sphinxAtStartPar
El software de ROS 2 se mantiene constantemente actualizado. Cada cierto
tiempo se lanza una nueva distribución, esto es, un conjunto versionado
de paquetes de ROS. Las actualizaciones se realizan de esta forma de
modo que se permite a los desarrolladores trabajar con una base de
código relativamente estable hasta que estén preparados para hacer
avanzar todo su trabajo a la siguiente distribución. Por lo tanto, una
vez que se libera una distribución, se trata de limitar los cambios a la
corrección de errores y a las mejoras que no rompan el núcleo de los
paquetes. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id13}{29}{]}

\sphinxAtStartPar
Las dos distribuciones que están activas actualmente son “Foxy fitzroy”,
que fue lanzada en junio de 2020, y “Galactic Geochelone”, que es la más
reciente, lanzada en mayo de 2021.

\sphinxAtStartPar
Para la realización de este trabajo se ha escogido la distribución de
Foxy, ya que, a pesar de no ser la más novedosa, es la distribución que
da soporte al software de micro\sphinxhyphen{}ROS, el cual se explicará en el
siguiente apartado.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=150\sphinxpxdimen]{{Foxy}.png}
\caption{Logotipo de la distribución «Foxy fitzroy»}\label{\detokenize{software:id20}}\end{figure}

\sphinxAtStartPar
Se pueden instalar los paquetes de ROS 2 Foxy Fitzroy tanto para Linux
(Ubuntu), Windows o MacOS. En nuestro caso se ha escogido la
distribución de Linux ya que originariamente ROS fue creada para este
sistema operativo y está más optimizada.


\subsection{Conceptos}
\label{\detokenize{software:conceptos}}
\sphinxAtStartPar
Para comprender el análisis llevado a cabo en este trabajo es necesario
conocer de una manera básica como funciona ROS 2. El sistema operativo
de robots funciona como un nexo entre dos o más sistemas o nodos.

\sphinxAtStartPar
Estos nodos tienen varias formas de comunicarse. La más sencilla es
mediante topics. Estos topics actúan como buses de información para
intercambiar mensajes entre nodos. Los nodos pueden actuar como
publicadores (publisher) o como suscriptores (subscribers). Los
publicadores son los encargados de publicar mensajes al topic y los
suscriptores son los que reciben esos mensajes del topic.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{topic_description-0}.png}
\caption{Funcionamiento de un topic (Fuente: ros.org)}\label{\detokenize{software:id21}}\end{figure}

\sphinxAtStartPar
Otra forma de comunicación entre nodos es mediante servicios. Estos
están basados en un modelo de solicitud y servicio. En este caso existe
un solo nodo que actúa como servidor (server) y uno o más nodos que
actúan como clientes (clients). Los clientes demandan un servicio y el
servidor responde con un mensaje. A diferencia de la comunicación
mediante topics, en este caso los clientes solo envían información
cuando esta ha sido pedida por otro nodo o cliente.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{Service-MultipleServiceClient-0}.png}
\caption{Funcionamiento de un servicio (Fuente: ros.org)}\label{\detokenize{software:id22}}\end{figure}

\sphinxAtStartPar
Finalmente, los nodos también pueden comunicarse mediante acciones.
Estas están constituidas por topics y servicios. El modelo de
comunicación es similar al de los servicios, con la peculiaridad de
que cuentan con un tópico que actúa de feedback entre el servidor y el
cliente, y dos servicios, uno para el objetivo que quiere cumplir el
cliente (goal service) y otro para los resultados obtenidos (result
service).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{Action-SingleActionClient-0}.png}
\caption{Funcionamiento de una acción (Fuente: ros.org)}\label{\detokenize{software:id23}}\end{figure}

\sphinxAtStartPar
Por otro lado, también es posible modificar el estado de un nodo
mediante parámetros. Estos son características propias del nodo que
pueden ser modificadas por los servidores de ROS. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id14}{30}{]}


\subsection{Instalación}
\label{\detokenize{software:instalacion}}
\sphinxAtStartPar
El proceso de instalación de ROS 2 se encuentra perfectamente explicado
en la documentación oficial, en la pagina web  {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id15}{28}{]}

\sphinxAtStartPar
Hay dos formas de instalar los paquetes de ROS 2 para Ubuntu. A
continuación se explicará de forma resumida la instalación llevada acabo
para la realización de este trabajo.

\sphinxAtStartPar
Se ha escogido la instalación con los paquetes Debian, debido a su
sencillez y rapidez. En primer lugar es necesario asegurarse que nuestro
local soporta el formato de codificación UTF\sphinxhyphen{}8.

\sphinxAtStartPar
En segundo lugar es necesario descargar la herramienta avanzada de paquetes
(APT) de ROS 2.

\sphinxAtStartPar
Finalmente, se instalan los paquetes de ROS 2. Para ello hay que
actualizar la caché del repositorio de la herramienta de paquetes y ya
se podrá utilizar para realizar la instalación de escritorio, que
contiene el ROS, demos, y tutoriales; y la instalación básica que
proporciona al sistema las librerías, los paquetes con los mensajes y
las herramientas de la linea de comandos.

\sphinxAtStartPar
Por último, es importante advertir que cada vez que se vaya a utilizar ROS
2 es necesario añadir el fichero “setup.bash” a la lista fuente.

\sphinxAtStartPar
Se muestran a continuación los comandos necesarios para ejecutar dichas acciones.
{[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id16}{31}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+c1}{\PYGZsh{} Set locale}

locale  \PYG{c+c1}{\PYGZsh{} check for UTF\PYGZhy{}8}
sudo apt update \PYG{o}{\PYGZam{}\PYGZam{}} sudo apt install locales
sudo locale\PYGZhy{}gen en\PYGZus{}US en\PYGZus{}US.UTF\PYGZhy{}8
sudo update\PYGZhy{}locale \PYG{n+nv}{LC\PYGZus{}ALL}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8 \PYG{n+nv}{LANG}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8
\PYG{n+nb}{export} \PYG{n+nv}{LANG}\PYG{o}{=}en\PYGZus{}US.UTF\PYGZhy{}8
locale  \PYG{c+c1}{\PYGZsh{} verify settings}

\PYG{c+c1}{\PYGZsh{} Setup Sources}

sudo apt update \PYG{o}{\PYGZam{}\PYGZam{}} sudo apt install curl gnupg2 lsb\PYGZhy{}release
sudo curl \PYGZhy{}sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key  \PYGZhy{}o /usr/share/keyrings/ros\PYGZhy{}archive\PYGZhy{}keyring.gpg
\PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{deb [arch=}\PYG{k}{\PYGZdl{}(}dpkg \PYGZhy{}\PYGZhy{}print\PYGZhy{}architecture\PYG{k}{)}\PYG{l+s+s2}{ signed\PYGZhy{}by=/usr/share/keyrings/ros\PYGZhy{}archive\PYGZhy{}keyring.gpg] http://packages.ros.org/ros2/ubuntu }\PYG{k}{\PYGZdl{}(}lsb\PYGZus{}release \PYGZhy{}cs\PYG{k}{)}\PYG{l+s+s2}{ main}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{|} sudo tee /etc/apt/sources.list.d/ros2.list \PYGZgt{} /dev/null

\PYG{c+c1}{\PYGZsh{} Install ROS 2 packages}

sudo apt update
sudo apt install ros\PYGZhy{}foxy\PYGZhy{}desktop
sudo apt install ros\PYGZhy{}foxy\PYGZhy{}ros\PYGZhy{}base

\PYG{c+c1}{\PYGZsh{}Environment setup}

\PYG{n+nb}{source} /opt/ros/foxy/setup.bash
\end{sphinxVerbatim}


\section{Micro\sphinxhyphen{}ROS}
\label{\detokenize{software:micro-ros}}

\subsection{Características principales}
\label{\detokenize{software:caracteristicas-principales}}
\sphinxAtStartPar
Micro\sphinxhyphen{}ROS posee siete características claves que lo convierten en un
software optimizado para microcontroladores: {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id18}{21}{]}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Una API adaptada para microcontroladores que incluye todos los
conceptos principales de ROS: Este \sphinxstyleemphasis{framework} adaptado cuenta con las
mismas prestaciones principales que ROS 2, como son la publicación y
suscripción a mensajes de un tópico por parte de nodos, la mecánica
de cliente/servicio, el ciclo de vida y el gráfico de nodos. Esta API
se basa en la biblioteca estándar de soporte de clientes de ROS 2
(rcl) y un conjunto de extensiones (rclc), que se explicarán
posteriormente.

\item {} 
\sphinxAtStartPar
Integración perfecta con ROS 2: El agente de micro\sphinxhyphen{}ROS se conecta con
los nodos de los microcontroladores a través de sistemas ROS 2
estándar. Esto permite acceder a los nodos micro\sphinxhyphen{}ROS con las
herramientas y APIs conocidas de ROS 2 como si se trataran de nodos
suyos.

\item {} 
\sphinxAtStartPar
Un middleware con recursos muy limitados pero de gran flexibilidad:
Micro\sphinxhyphen{}ROS utiliza Micro XRCE\sphinxhyphen{}DDS de eProsima como middleware para
sistemas embebidos. Este software es el nuevo estándar de DDS para
entornos con recursos limitados, el cual se explicará en el siguiente
capítulo. Para la integración con la interfaz del middleware de ROS
(rmw) en la pila de micro\sphinxhyphen{}ROS, se introdujeron herramientas de
memoria estática para evitar asignaciones de memoria dinámica en
tiempo de ejecución.

\item {} 
\sphinxAtStartPar
Soporte de varios sistemas operativos en tiempo real con un sistema
de compilación genérico: Otro de los softwares requeridos para la
ejecución de programas en sistemas de tiempo real es un sistema
operativo en tiempo real, el cual se explicará más adelante.
Micro\sphinxhyphen{}ROS soporta tres populares sistemas operativos en tiempo real
(a partir de ahora RTOS) de código abierto: FreeRTOS, Zephyr y Nuttx.
Además puede ser portado a cualquier RTOS que tenga una interfaz
POSIX.
Los sistemas de compilación específicos de RTOS están integrados en
algunos scripts de configuración genéricos, que se proporcionan como
un paquete de ROS 2. Además, micro\sphinxhyphen{}ROS proporciona herramientas
específicas para algunos de estos RTOS.

\item {} 
\sphinxAtStartPar
Software de licencia permisiva: Micro\sphinxhyphen{}ROS se encuentra bajo la misma
licencia que ROS 2, “Apache License 2.0”. Esto se aplica a la
biblioteca del cliente de micro\sphinxhyphen{}ROS, la capa de middleware y las
herramientas.

\item {} 
\sphinxAtStartPar
Comunidad y ecosistema muy activos: Micro\sphinxhyphen{}ROS ha sido desarrollado
por una comunidad auto\sphinxhyphen{}organizada y en constante crecimiento,
respaldada por el “Embedded Working Group”, un grupo serio de trabajo
de ROS 2. Esta comunidad proporciona apoyo a través de GitHub y
comparte tutoriales de nivel básico. Aparte de eso, también crea
herramientas en torno a micro\sphinxhyphen{}ROS para optimizar las aplicaciones ya
creadas al hardware del microcontrolador. Estas permiten comprobar el
uso de la memoria, el consumo de tiempo de la CPU y el rendimiento
general.

\item {} 
\sphinxAtStartPar
Mantenibilidad e interoperabilidad a largo plazo: Micro\sphinxhyphen{}ROS está
formado por varios componentes independientes. Varios RTOSes de
código abierto con cierto renombre, un middleware estandarizado y la
biblioteca estándar de soporte de clientes ROS 2 (rcl). De este modo
se minimiza la cantidad de código específico de micro\sphinxhyphen{}ROS para su
mantenimiento a largo plazo. Al mismo tiempo, la pila de micro\sphinxhyphen{}ROS
conserva la modularidad de la pila estándar de ROS 2. Esto se traduce
en que el software de micro\sphinxhyphen{}ROS no depende de si mismo para
garantizar un buen mantenimiento, sino que está respaldado por otros
componentes con más soporte detrás y que podrían ser sustituibles.

\end{itemize}


\subsection{Instalación}
\label{\detokenize{software:id6}}
\sphinxAtStartPar
Después de instalar ROS 2, es necesario crear un espacio de trabajo para
micro\sphinxhyphen{}ROS. Una vez creado, se clona el repositorio de github que
contiene las herramientas y los ficheros para instalar micro\sphinxhyphen{}ROS.
Finalmente, se compilan todos los ficheros y se obtendrían las
herramientas principales de micro\sphinxhyphen{}ROS. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id19}{14}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+c1}{\PYGZsh{} Source the ROS 2 installation}

\PYG{n+nb}{source} /opt/ros/ \PYG{n+nv}{\PYGZdl{}ROS\PYGZus{}DISTRO} /setup.bash

\PYG{c+c1}{\PYGZsh{} Create a workspace and download the micro\PYGZhy{}ROS tools}

mkdir microros\PYGZus{}ws

\PYG{n+nb}{cd} microros\PYGZus{}ws

git clone \PYGZhy{}b \PYG{n+nv}{\PYGZdl{}ROS\PYGZus{}DISTRO} https://github.com/micro\PYGZhy{}ROS/micro\PYGZus{}ros\PYGZus{}setup.git src/micro\PYGZus{}ros\PYGZus{}setup

\PYG{c+c1}{\PYGZsh{} Update dependencies using rosdep}

sudo apt update  \PYG{o}{\PYGZam{}\PYGZam{}} rosdep update

rosdep install \PYGZhy{}\PYGZhy{}from\PYGZhy{}path src \PYGZhy{}\PYGZhy{}ignore\PYGZhy{}src \PYGZhy{}y

\PYG{c+c1}{\PYGZsh{} Install pip}

sudo apt\PYGZhy{}get install python3\PYGZhy{}pip

\PYG{c+c1}{\PYGZsh{} Build micro\PYGZhy{}ROS tools and source them}

colcon build

\PYG{n+nb}{source} install /local\PYGZus{}setup.bash
\end{sphinxVerbatim}


\subsection{Arquitectura modular}
\label{\detokenize{software:arquitectura-modular}}
\sphinxAtStartPar
Micro\sphinxhyphen{}ROS sigue la arquitectura de ROS 2, y aprovecha su capacidad de
conexión del middleware para utilizar el DDS para microcontroladores
(DDS\sphinxhyphen{}XRCE). Además utiliza los RTOS basados en POSIX en lugar
de Linux.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{estructura_micro_ros}.png}
\caption{Estructura de micro\sphinxhyphen{}ROS (Fuente: micro\sphinxhyphen{}ROS.org)}\label{\detokenize{software:id24}}\end{figure}

\sphinxAtStartPar
A continuación se procederá a explicar los componentes que forman la
arquitectura de Micro\sphinxhyphen{}ROS divididos en tres grupos: librería del
cliente, middleware y RTOS.


\subsection{Librería del cliente}
\label{\detokenize{software:libreria-del-cliente}}
\sphinxAtStartPar
El objetivo general de esta librería es proporcionar todos los conceptos
relevantes de ROS 2 en implementaciones adecuadas para
microcontroladores y posteriormente lograr la compatibilidad de la API
con ROS 2 para facilitar la portabilidad. Para minimizar el coste de
mantenimiento a largo plazo, se trata de utilizar las estructuras de
datos y los algoritmos existentes de la pila de ROS 2, o bien introducir
los cambios necesarios en la pila principal. Esto genera una
preocupación por la dudosa aplicabilidad de las capas existentes de ROS
2 en los microcontroladores en términos de eficiencia en tiempo de
ejecución, la portabilidad a diferentes RTOS, la gestión de memoria
dinámica, etc.

\sphinxAtStartPar
C es el lenguaje de programación dominante en los microcontroladores.
Sin embargo, existe una clara tendencia a utilizar lenguajes de alto
nivel, especialmente C++, debido a que los microcontroladores más
modernos ya cuentan hasta con una mayor memoria RAM. Es por ello por
lo que micro\sphinxhyphen{}ROS pretende ofrecer y soportar dos APIs.
\begin{itemize}
\item {} 
\sphinxAtStartPar
La API en C basada en la librería de soporte de ROS 2 (rcl): Esta API
está formada principalmente por paquetes modulares para el
diagnóstico, la gestión de la ejecución y los parámetros.

\item {} 
\sphinxAtStartPar
La API en C++ basada en la rclcpp de ROS 2: Esta API en cambio,
requiere primero de la aptitud de rclcpp para su uso en
microcontroladores, en particular cuando se trata de la memoria, el
consumo de CPU y la gestión de la memoria dinámica. Esta incluye las
estructuras de datos relacionadas con la generación de mensajes como
pueden ser los topics, los servicios y las acciones.

\end{itemize}

\sphinxAtStartPar
Dentro de estas APIs existen paquetes diseñados específicamente para
micro\sphinxhyphen{}ROS. La librería rclc cuenta con numerosas extensiones dedicadas a
microcontroladores. Cuenta con funciones como temporizadores, logging,
gráficos específicos, modificación de parámetros, etc.

\sphinxAtStartPar
Además de estas aplicaciones, se han desarrollado varios conceptos
avanzados en el contexto de la librería del cliente. En general, estos
conceptos se desarrollan primero para el rclcpp estándar antes de
implementar una versión en C adaptada. Estas funciones son las
siguientes: {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id20}{12}{]}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ejecutor en tiempo real: El objetivo de este módulo consiste en
aportar mecanismos de tiempo real prácticos y fáciles de usar que
proporcionen soluciones para garantizar los requisitos de tiempo
demandados. También pretende integrar funcionalidades de tiempo real
o no real en una plataforma de ejecución y soporte específico para
RTOS y microcontroladores.

\item {} 
\sphinxAtStartPar
Ciclo de vida y modos del sistema: En micro\sphinxhyphen{}ROS se ha detectado que
el entrelazamiento de la gestión de tareas, la gestión de imprevistos
y la gestión de errores del sistema, que se manejan en la capa de
deliberación, generalmente conduce a la alta complejidad del flujo de
control, algo que podría reducirse introduciendo abstracciones
adecuadas para las llamadas y notificaciones orientadas al sistema.
El objetivo de esta funcionalidad reside en proporcionar
abstracciones y funciones marco adecuadas para la configuración del
tiempo de ejecución del sistema y el diagnóstico de errores y
contingencias del sistema.

\item {} 
\sphinxAtStartPar
Transformación integrada: El gráfico de transformación es una
herramienta que, desde su lanzamiento, ha sido fundamental para los
marcos de trabajo de robótica. Sin embargo, un problema persistente
ha sido su alto consumo de recusos. Micro\sphinxhyphen{}ROS ejecuta el árbol de
transformación dinámico en un dispositivo integrado, manteniendo el
uso de recursos al mínimo, basándose en un análisis de los detalles
espaciales y temporales que realmente necesitan.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{micro-ROS_client_library}.png}
\caption{Arquitectura de la librería del cliente (Fuente: fiware.com)}\label{\detokenize{software:id25}}\end{figure}


\subsection{Middleware}
\label{\detokenize{software:middleware}}
\sphinxAtStartPar
La principal característica de los softwares de robots es la
comunicación entre distintos nodos que permita el intercambio de
información con unas características determinadas.

\sphinxAtStartPar
Para implementar todos esos conceptos de comunicación, en ROS 2 se
decidió hacer uso de un middleware ya existente llamado DDS. De esta
forma, ROS 2 puede aprovechar una implementación enfocada en ese sector
ya existente y bien desarrollada. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id21}{2}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{micro-ROS_middleware}.png}
\caption{Arquitectura del middleware (Fuente: fiware.com)}\label{\detokenize{software:id26}}\end{figure}

\sphinxAtStartPar
DDS son las siglas de Data Distribution Service. Es un servicio de
distribución de datos que sirve como estándar de comunicación de
sistemas en tiempo real para los middlewares de tipo publish/subscribe,
como puede ser ROS. Fue creado debido a la necesidad de estandarizar los
sistemas centrados en datos. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id22}{34}{]}

\sphinxAtStartPar
Existen numerosas implementaciones distintas de DDS y cada una tiene sus
ventajas y sus desventajas en términos de plataformas soportadas,
rendimiento, licencias, dependencias y huellas de memoria. Es por ello
por lo que ROS pretende soportar múltiples implementaciones DDS a pesar
de que cada una de ellas difiera ligeramente en su API. Para abstraerse
de dichas especificaciones, se ha introducido una interfaz abstracta que
puede ser implementada para diferentes DDS. Esta interfaz de middleware
define la API entre la librería del cliente de ROS y cualquier
implementación específica.

\sphinxAtStartPar
Como ya se ha comentado en el anterior párrafo, ROS 2 da soporte a
varias DDS. La más utilizada y considerada la DDS por defecto en la
distribución «Foxy fitzroy» es la
“Fast DDS” de eProsima. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id23}{9}{]}
Esta implementación está diseñada en C++ e
implementa el protocolo RTPS (Real Time Publish Subscribe), el cual
permite comunicaciones a través de distintos medios como el protocolo de
datagrama de usuario (UDP), un protocolo ligero de transporte de datos
que funciona sobre IP. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id24}{1}{]}

\sphinxAtStartPar
Para adaptar todo este mecanismo de comunicación a Micro\sphinxhyphen{}ROS, eProsima
ha desarrollado “Micro XRCE\sphinxhyphen{}DDS”. Esta adaptación permite comunicar
entornos con recursos extremadamente limitados (eXtremely Resource
Constrained Environments, XRCE) con una red existente de DDS. La
librería Micro XRCE\sphinxhyphen{}DDS implementa un protocolo de cliente/servidor que
permite a los microcontroladores participar en comunicaciones de DDS. El
agente de Micro XRCE\sphinxhyphen{}DDS actúa como un puente entre el cliente y el
espacio de datos de DDS y permite a estos dispositivos actuar como
publicadores y suscriptores o como clientes y servidores.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{xrcedds_architecture}.png}
\caption{Arquitectura de Micro XRCE\sphinxhyphen{}DDS (Fuente: freertos.org)}\label{\detokenize{software:id27}}\end{figure}

\sphinxAtStartPar
Dentro de las características principales de Micro XRCE\sphinxhyphen{}DDS, cabe
destacar las siguientes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Alto rendimiento: El cliente utiliza una librería de serialización
de bajo nivel que codifica en XCDR.

\item {} 
\sphinxAtStartPar
Bajo consumo de recursos: El cliente de la librería XRCE está libre de memoria
dinámica y estática, por lo que la única huella de memoria se
debe al crecimiento de la pila. Puede gestionar un emisor/suscriptor simple
con menos de 2 kB de RAM. Además el cliente está construido según un
concepto de perfiles, lo que permite añadir o eliminar funcionalidades a la
librería al mismo tiempo que modifica su tamaño.

\item {} 
\sphinxAtStartPar
Multiplataforma: Las dependencias del sistema operativo son módulos aditivos,
por lo que los usuarios pueden implementar los módulos específicos de cada
plataforma a la librería del cliente. Por defecto, el sistema permite
trabajar con los sistemas operativos estándar Windows y Linux, y con los
RTOS Nuttx, FreeRTOS y Zephyr.

\item {} 
\sphinxAtStartPar
Multitransporte: A diferencia de otros middlewares de transferencia de datos,
XRCE\sphinxhyphen{}DDS soporta múltiples protocolos de transporte de forma nativa. En
concreto, es posible utilizar los protocolos UDP, TCP o un protocolo de
transporte en serie personalizado.

\item {} 
\sphinxAtStartPar
De código abierto: La librería del cliente, el ejecutable del agente,
la herramienta de compilación y otras dependencias internas son libres y de
código abierto.

\item {} 
\sphinxAtStartPar
Dos modos de funcionamiento: Micro XRCE\sphinxhyphen{}DDS soporta dos modos de
funcionamiento. El modo \sphinxstyleemphasis{best\sphinxhyphen{}effort} implementa una comunicación
rápida y ligera, mientras que el modo \sphinxstyleemphasis{reliable} asegura la fiabilidad
independientemente de la capa de transporte utilizada.

\end{itemize}


\subsection{RTOS}
\label{\detokenize{software:rtos}}
\sphinxAtStartPar
Como ya se ha explicado previamente, RTOS significa sistema operativo en
tiempo real. Esto es un sistema operativo ligero que se emplea para facilitar
la multitarea y la integración de tareas en sistemas con recursos y tiempo
limitados. La clave de un RTOS es la previsibilidad y el determinismo en el
tiempo de ejecución más que la inmediatez, ya que lo fundamental en un
sistema que opera de este modo es que realice una serie de tareas en un tiempo
determinado, y no necesariamente lo más rápido posible. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id25}{5}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{micro-ROS_RTOS}.png}
\caption{Arquitectura del RTOS (Fuente: fiware.com)}\label{\detokenize{software:id28}}\end{figure}

\sphinxAtStartPar
Un sistema operativo de este tipo cuenta con las siguientes características:
no utiliza gran cantidad de memoria, es susceptible de actuar tras eventos
realizados en el soporte físico, un tiempo de respuesta predecible, fiabilidad
y multi\sphinxhyphen{}arquitectura (esto es la posibilidad de portar el código a cualquier
tipo de CPU). {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id37}{37}{]}

\sphinxAtStartPar
Los RTOS suelen utilizar capas de abstracción de hardware que facilitan
el uso de recursos del hardware, como temporizadores y buses de comunicación,
aligerando el desarrollo y permitiendo la reutilización de código.
Además, ofrecen entidades de hilos y tareas que proporcionan las
herramientas necesarias para implementar el determinismo en las aplicaciones.
La programación consta de diferentes algoritmos, entre los que mejor se adapten
a sus aplicaciones.

\sphinxAtStartPar
Debido a todos los beneficios que ofrecen estos sistemas operativos,
micro\sphinxhyphen{}ROS los integra en su pila de software. Esto mejora las capacidades
de micro\sphinxhyphen{}ROS Y permite reutilizar todas las herramientas y funciones
proporcionadas por estos.

\sphinxAtStartPar
Al igual que los sistemas operativos convencionales, los RTOS también
tienen diferentes soportes para las interfaces estándar. Esto se establece
en una familia de estándares denominada POSIX. Este  está basado en Linux,
el sistema operativo nativo de ROS 2, por lo que la portabilidad de gran parte
del código de este a micro\sphinxhyphen{}ROS se facilita empleando los RTOS de este grupo.
Tanto NuttX como Zephyr cumplen en buena medida con los estándares POSIX,
haciendo que el esfuerzo de portabilidad sea mínimo, mientras que FreeRTOS
proporciona un plugin, FreeRTOS+POSIX, gracias al cual una aplicación
existente que cumpla con POSIX puede ser fácilmente portada al ecosistema
FreeRTOS. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id26}{19}{]}

\sphinxAtStartPar
A pesar de que todos utilizan el mismo código base de micro\sphinxhyphen{}ROS y que
sus herramientas han sido integradas en el sistema de compilación de ROS 2,
existen notables diferencias en sus características. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id27}{15}{]}

\sphinxAtStartPar
A la hora de escoger un RTOS aparecen varios factores a tener en cuenta:
La responsabilidad y exposición legal, el rendimiento, las características
técnicas, el coste, el ecosistema, el middleware a emplear, el proveedor
y la preferencia de ingeniería. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id28}{4}{]}

\sphinxAtStartPar
FreeRTOS ha sido el sistema operativo en tiempo real escogido para la
realización de este análisis, debido a que es el que mejor se adapta a la placa
que se usará en el mismo. Este es distribuido bajo la licencia MIT. Las
propiedades clave de este RTOS son las herramientas de gestión de memoria
que contiene, los recursos de transporte que ofrece, TCP/IP y IwIP, las tareas
estándar y ociosas disponibles con prioridades asignables, la disponibilidad
de la extensión POSIX y el tamaño tan reducido que ocupa, permitiendo ser
utilizada en prácticamente cualquier microcontrolador. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id29}{20}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{freertos}.jpeg}
\caption{Logotipo de FreeRTOS}\label{\detokenize{software:id29}}\end{figure}


\chapter{Hardware}
\label{\detokenize{hardware:hardware}}\label{\detokenize{hardware::doc}}
\sphinxAtStartPar
Micro\sphinxhyphen{}ROS tiene como objetivo llevar ROS 2 a un amplio conjunto
de microcontroladores para conseguir tener entidades de ROS 2 de
primera clase en el mundo embebido. Los principales objetivos de
micro\sphinxhyphen{}ROS son las familias de microcontroladores de gama media de 32 bits.
Normalmente, los requisitos mínimos para ejecutar micro\sphinxhyphen{}ROS en una
plataforma embebida son las restricciones de memoria. En general, micro\sphinxhyphen{}ROS
necesitará microcontroladores que contengan decenas de kilobytes de memoria
RAM y periféricos de comunicación que permitan la comunicación entre el
cliente y el agente de micro\sphinxhyphen{}ROS.

\sphinxAtStartPar
El soporte de hardware de micro\sphinxhyphen{}ROS se divide en dos categorías,
las placas con soporte oficial y las placas soportadas por la comunidad.
Dentro de la gran cantidad de gamas de placas que poseen soporte directo
de micro\sphinxhyphen{}ROS, encontramos dispositivos de proveedores con cierto renombre
como Renesas, Espressif, Arduino, Raspberry, ROBOTICS, Teensy, ST, Olimex,
etc. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id30}{18}{]}


\section{ESP\sphinxhyphen{}32}
\label{\detokenize{hardware:esp-32}}
\sphinxAtStartPar
La placa que se ha utilizado para la medición de los tiempos de
respuesta ha sido la “Espressif ESP32”. Esta posee numerosas cualidades
positivas que se explicarán a continuación. Sin embargo, las razones
principales de esta elección han sido su bajo consumo, la posibilidad
de conexión vía WIFI y la activa comunidad y soporte que ofrece micro\sphinxhyphen{}ROS
a Espressif.

\sphinxAtStartPar
Espressif es una empresa pionera en el mundo del internet de las
cosas (IoT). Son un equipo de especialistas en creación de chips y desarrollo
de software. Una particularidad de esta empresa es el apoyo que proporcionan
a sus clientes para construir sus propias soluciones y conectar con otros
socios del mundo IoT. Los productos de Espressif se han implementado
principalmente en el mercado de placas, cajas OTT
(servicios de libre transmisión), cámaras e IoT. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id31}{3}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{esp32}.jpg}
\caption{Placa ESP32}\label{\detokenize{hardware:id5}}\end{figure}

\sphinxAtStartPar
El modelo concreto que se ha utilizado es la “ESP32\sphinxhyphen{}DevKitC V4”.
Forma parte de las placas de desarrollo o “DevKits”, dispositivos de
reducido tamaño y accesibles para programadores inexpertos diseñadas para
facilitar el prototipado. Estas están alimentadas por un módulo que les
suministra la mayoría de funcionalidades. La disposición de los pines de
entrada/salida están repartidos en ambos lados para facilitar la interconexión.
Los desarrolladores pueden conectar los periféricos con cables puente
o montar la DevkitC en una protoboard. Una de las particularidades que
más destacan de estos modelos son la posibilidad de conexión vía Wi\sphinxhyphen{}Fi
y Bluetooth. Esto permite realizar prototipos inalámbricos que simulan
un entorno con muchas posibilidades que se asemeja más a la idea original
del IoT. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id32}{6}{]}

\sphinxAtStartPar
La DevKitc V4 que se ha utilizado cuenta con los siguientes componentes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Un módulo ESP32\sphinxhyphen{}WROOM\sphinxhyphen{}32D

\item {} 
\sphinxAtStartPar
Botón de reseteo “EN”

\item {} 
\sphinxAtStartPar
Botón de descarga “Boot”: Presionando el botón “Boot” y después
pulsando el botón “EN”, inicia la descarga del firmware a través
del puerto en serie.

\item {} 
\sphinxAtStartPar
Puente de USB a UART: Permite la transferencia de datos desde un
puerto de tipo USB a un puerto UART.

\item {} 
\sphinxAtStartPar
Puerto Micro USB: Sirve tanto como fuente de alimentación como de
interfaz de comunicación entre el ordenador y el módulo ESP32\sphinxhyphen{}WROOM\sphinxhyphen{}32D.

\item {} 
\sphinxAtStartPar
Led de encendido de 5V: Se enciende cuando el USB u otra fuente de
alimentación está conectada a la placa.

\item {} 
\sphinxAtStartPar
Entradas/salidas: La mayoría de los pines del módulo están repartidos
en los cabezales de los pines de la placa. A través de ellos se pueden
programar múltiples funciones como PWM, ADC, DAC, I2C, I2S, SPI, etc.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{esp32-devkitc-functional-overview}.jpg}
\caption{Componentes de la placa ESP32 (Fuente: Espressif)}\label{\detokenize{hardware:id6}}\end{figure}

\sphinxAtStartPar
El ESP32\sphinxhyphen{}WROOM\sphinxhyphen{}32D es un módulo de microcontrolador genérico que se dirigen
a una amplia gama variedad de aplicaciones, que van desde redes de sensores
de baja potencia hasta otras tareas de mayor exigencia, como codificación
de voz, transmisión de música y decodificación de MP3.

\sphinxAtStartPar
El núcleo de este módulo es el chip ESP32\sphinxhyphen{}D0WD. El chip está diseñado para
ser escalable y adaptable. Existen dos núcleos de CPU que pueden ser
controlados individualmente y la frecuencia de reloj es ajustable de 80 MHz
a 240 MHz. El chip cuenta con un coprocesador de bajo consumo que
puede utilizarse en lugar de la CPU para ahorrar energía en tareas
que no requieren mucha potencia de cálculo, como la monitorización de
periféricos. ESP32 cuenta con un amplio conjunto de periféricos integrables,
que van desde sensores táctiles capacitivos, sensores Hall, interfaz
de tarjeta SD, Ethernet, SPI de alta velocidad, UART, I2S e I2C.

\sphinxAtStartPar
La integración de Bluetooth y Wi\sphinxhyphen{}Fi garantiza que se pueda abordar
una amplia gama de aplicaciones y una gran polivalencia del módulo.
El uso de Wi\sphinxhyphen{}Fi permite un gran alcance físico y la conexión directa
a Internet a través de un router, mientras que el uso de Bluetooth
permite al usuario conectarse cómodamente al teléfono o emitir balizas
de baja energía para su detección.

\sphinxAtStartPar
La corriente de reposo del chip ESP32 es inferior a 5 uA, hecho que lo
convierte adecuado para aplicaciones alimentadas por batería y de electrónica
portátil. El módulo admite una velocidad de datos de hasta 150 Mbps y
una potencia de salida de 20 dBm en la antena para garantizar el mayor
alcance físico posible.

\sphinxAtStartPar
El sistema operativo elegido para ESP32 es freeRTOS con LwIP,
aunque también se ha incorporado TLS 1.2 con aceleración por hardware. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id33}{7}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{WROOM32D}.jpg}
\caption{Módulo ESP32\sphinxhyphen{}WROOM\sphinxhyphen{}32D}\label{\detokenize{hardware:id7}}\end{figure}


\section{Computador}
\label{\detokenize{hardware:computador}}
\sphinxAtStartPar
Todo el trabajo se ha realizado haciendo uso de un ordenador personal,
de unos 4 años de uso que se encuentra en perfecto estado.
Este es un Asus UX340.
Este ordenador portátil cuenta con 16 GB de memoria RAM, 256 GB de
almacenamiento SSD, arquitectura de 64 bits y un microprocesador Intel i5.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=150\sphinxpxdimen]{{asus_UX430U}.jpg}
\caption{Asus UX430U}\label{\detokenize{hardware:id8}}\end{figure}

\sphinxAtStartPar
Se ha utilizado el sistema operativo Linux, en la distribución Ubuntu 20.04.3 LTS.


\section{Cable micro\sphinxhyphen{}USB}
\label{\detokenize{hardware:cable-micro-usb}}
\sphinxAtStartPar
En el transcurso del proyecto se han utilizado dos cables. En
primer lugar se utilizó un cable estándar, sin embargo, no permitía
entregar toda la potencia requerida por la placa. Seguidamente se
sustituyó por un cable de calidad superior.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=150\sphinxpxdimen]{{cable_micro_usb}.jpg}
\caption{Cable micro\sphinxhyphen{}USB}\label{\detokenize{hardware:id9}}\end{figure}


\section{Router TP\sphinxhyphen{}Link}
\label{\detokenize{hardware:router-tp-link}}
\sphinxAtStartPar
Para obtener unas medidas que no se vean alteradas por el tráfico
que pueda existir en la red doméstica, se ha adquirido un router
adicional. Este es un Archer 80 de la marca TP\sphinxhyphen{}Link.
Cuenta con 1300 Mbps en la banda de 5 GHz y 600 Mbps en la banda
de 2.4 GHz. Tiene una tecnología MIMO 3x3 con cobertura de Wi\sphinxhyphen{}Fi
potenciada. Este se conectará por cable a una red doméstica de 1Gbps
de descarga.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=150\sphinxpxdimen]{{tp_link}.jpg}
\caption{Router TP\sphinxhyphen{}Link}\label{\detokenize{hardware:id10}}\end{figure}


\chapter{Diseño del análisis}
\label{\detokenize{dise_xf1o_del_analisis:diseno-del-analisis}}\label{\detokenize{dise_xf1o_del_analisis::doc}}

\section{Preparación previa}
\label{\detokenize{dise_xf1o_del_analisis:preparacion-previa}}
\sphinxAtStartPar
Para realizar todas las mediciones de este trabajo, ha sido preciso
un estudio previo del entorno y una preparación para la utilización
del software a probar.

\sphinxAtStartPar
En primer lugar, es necesario conocer el funcionamiento de la placa.
Desde la propia página de Espressif es posible encontrar un documento
con todos los pasos detallados para iniciarse en la programación de la
placa. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id34}{8}{]}

\sphinxAtStartPar
Al principio se necesita instalar los requisitos de la aplicación en
función del sistema operativo en el que se opere. Después, hay que instalar
una serie de librerías proporcionadas por Espressif denominadas ESP\sphinxhyphen{}IDF.
Posteriormente, se instalará una serie de herramientas y se configurarán las
variables de entorno. Una vez realizados estos pasos, ya será posible crear
un proyecto para la placa para comprobar que funciona correctamente.

\sphinxAtStartPar
Una vez comprobado el correcto funcionamiento de la placa, es necesario
instalar el software de micro\sphinxhyphen{}ROS y realizar una serie de pruebas.
Es posible realizar primero una serie de prácticas con clientes
creados dentro del propio Linux. Para ello hay que instalar y compilar
el firmware adecuado, crear un agente de micro\sphinxhyphen{}ROS y ejecutar la aplicación.
Si todo funciona correctamente, será posible observar una serie de mensajes
publicados en el topic en cuestión. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id35}{16}{]}

\sphinxAtStartPar
Después de realizar unas primeras prácticas tanto con el software como con
el hardware que se quiere probar, es el momento de unir ambas partes y realizar
las primeras pruebas de micro\sphinxhyphen{}ROS en la placa.

\sphinxAtStartPar
Para ello hay que seguir un tutorial similar al anterior en el que se explica
como realizar una primera aplicación de micro\sphinxhyphen{}ROS con conexión vía Wi\sphinxhyphen{}Fi.
{[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id36}{33}{]}

\sphinxAtStartPar
Inicialmente, hay que crear y configurar un nuevo firmware de trabajo.
En este momento hay que escoger el RTOS sobre el que se va a trabajar y
descargar sus herramientas y librerías propias. Posteriormente es necesario
configurar dicho firmware, especificando la aplicación que se quiere probar
y el tipo de conexión que se quiere establecer con la placa. Además, es necesario
operar sobre un menú de la propia placa en el que se pueden modificar numerosos
aspectos de la misma, como las variables de entorno o las especificaciones
de la conexión (p.e. SSID y contraseña Wi\sphinxhyphen{}Fi).

\sphinxAtStartPar
Una vez configurado, se compilará y se flasheará a la placa. En este momento
se envía la aplicación a la placa vía USB y esta se ejecuta. Sin embargo, es
necesario crear un agente en Linux para que la placa pueda conectarse a un
espacio de datos y publicar los mensajes. Tras realizar dicha acción, podrá
observarse cierta información en el agente creado, confirmando el establecimiento
de conexión entre el agente y el cliente. Este será el momento en el que podremos
comprobar que todo funciona correctamente. Mediante el comando «ros2 topic list»
se mostrará el topic creado y con \sphinxcode{\sphinxupquote{ros2 topic echo /{[}project name{]}}} podremos
suscribirnos y observar los mensajes enviados por el cliente.

\sphinxAtStartPar
Después de realizar unas pruebas con las demos que proporciona el sistema
operativo, es recomendable realizar una serie de tutoriales más avanzados
que proporciona la propia página de micro\sphinxhyphen{}ROS. %
\begin{footnote}[1]\sphinxAtStartFootnote
micro\sphinxhyphen{}ROS. Micro\sphinxhyphen{}ROS programming tutorial. URL: \sphinxurl{https://micro.ros.org/docs/tutorials/programming\_rcl\_rclc/overview}.
%
\end{footnote}
En estos se enseña cómo diseñar tu propia aplicación, incluyendo cómo
crear tu propio nodo, tus publishers y subscribers, un temporizador o
incluso seleccionar la calidad de la comunicación.


\section{Estructura principal del análisis}
\label{\detokenize{dise_xf1o_del_analisis:estructura-principal-del-analisis}}
\sphinxAtStartPar
Lo primero que hay que hacer en el momento de diseñar un test de comportamiento
de un software es definir los parámetros que se van a medir y en qué condiciones.
Existen multitud de variables que se ven afectadas a la hora de realizar una
medición que aportan distintos tipos de información. Sin embargo, por distintas
razones, no es posible analizar todas ellas y es recomendable centrarse en un
número limitado de ellas para indagar más a fondo y obtener unas conclusiones
más concisas.

\sphinxAtStartPar
En este experimento se van a analizar la latencia global del sistema operativo
en tiempo real, el “throughput” o tasa de transferencia efectiva, el consumo
de memoria del sistema y la influencia de una interferencia externa en la red de ROS.

\sphinxAtStartPar
A continuación se explicará detalladamente en que consisten estos parámetros
y de que manera pueden afectar a un sistema en tiempo real.

\sphinxAtStartPar
La latencia es el retraso entre los eventos generados por un hardware y la
transmisión efectiva de datos. En otras palabras, la latencia es el tiempo que
tarda en ejecutarse una tarea desde el momento en el que es ordenada.
Esto en un sistema en tiempo real es crucial, ya que es uno de los principales
responsables de que se cumplan o no los tiempos que deben de cumplir los sistemas.
{[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id41}{35}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{latency}.png}
\caption{Latencia (Fuente: Inube)}\label{\detokenize{dise_xf1o_del_analisis:id8}}\end{figure}

\sphinxAtStartPar
Generalmente, un evento en un sistema de este estilo está formado por distintos
eventos más pequeños que dan lugar a la realización del evento principal. Por
este motivo, la latencia general del evento se descompone en varias latencias
más pequeñas que sumadas dan lugar a la latencia general del evento. En nuestro
caso, el evento comprende desde el momento en el que la aplicación ordena el envío
del mensaje hasta que este es publicado en el DDS, momento en el que este podrá
ser enviado a otros clientes que estén suscritos al topic.
Aquí se pueden encontrar distintas latencias. En primer lugar, el tiempo de respuesta
que emplea el microcontrolador en reaccionar al envío del mensaje. Seguidamente,
cabe recalcar el tiempo que tarda esta información en enviarse desde el cliente
al agente al que está conectado. Finalmente, es importante el tiempo que emplea
el agente en publicar los mensajes en el DDS.

\sphinxAtStartPar
Este último es el parámetro que se ha escogido para representar en un análisis, ya
que el sistema operativo en el que se lanza el agente nos proporciona herramientas
que nos indican las latencias que ocurren en el sistema con alta precisión.

\sphinxAtStartPar
El throughput es el segundo parámetro que se va a medir en el test de comportamiento.
Esta variable muestra la capacidad de transmisión del sistema. Esta puede verse
limitada por distintos aspectos, tanto correspondientes al software tanto como
al hardware. En este ámbito, el factor más limitante va a residir en el microcontrolador,
ya que es una placa diseñada para operar con recursos muy limitados. En este
sentido resultará muy interesante comprobar el momento en el que se produzca la
saturación de la placa para determinar las limitaciones del sistema y para qué aplicaciones
podría emplearse el microcontrolador.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{throughput}.jpeg}
\caption{Throughput (Fuente: Corporate Finance Institute)}\label{\detokenize{dise_xf1o_del_analisis:id9}}\end{figure}

\sphinxAtStartPar
Seguidamente, se procederá a estudiar el consumo se memoria del sistema. En un principio,
micro\sphinxhyphen{}ROS es un software diseñado para microcontroladores, por lo que el efecto
de las acciones realizadas por este en el sistema global no deberían ser notables.
En este sentido, será interesante comprobar si realmente se trata de un sistema que
economiza los recursos y hasta qué punto.

\sphinxAtStartPar
Por último, se va a someter al sistema a una perturbación externa. Se creará
un topic adicional y será el propio ordenador el que actue como cliente. Se ha decidido
escoger la demo «ping\_pong» para este propósito, ya que es una de las demos que trae
micro\sphinxhyphen{}ROS más completa, ya que crea dos nodos, un publisher y un subscriber y crea
una conexión constante entre ellos dos. Una vez añadida esta interferencia en la red,
se repetirán las mediciones de la latencia para comprobar si esta se ve afectada y
en qué manera.

\sphinxAtStartPar
Los parámetros previamente mencionados aportarán información de gran interés de
cara a formalizar una idea general del rendimiento del software y del hardware
en valores absolutos. Sin embargo, al no conocerse un estudio semejante, resulta
difícil otorgarle un valor relativo a dichos resultados frente a otros sistemas.
Es por ello por lo que se han escogido varios escenarios para la realización de
pruebas. De este modo sera posible obtener unas conclusiones que expresen tanto
un sentido absoluto como relativo.

\sphinxAtStartPar
Se han diseñado cuatro escenarios para la obtención de datos. Como ya se ha comentado
previamente, la placa ESP32 cuenta con la peculiaridad de ofrecer conexión vía Wi\sphinxhyphen{}Fi,
algo poco habitual en placas de este estilo, además de una conexión en serie más
convencional. De otro modo, ya se ha explicado en el apartado de «software» que
micro\sphinxhyphen{}ROS cuenta con dos modos de comunicación para el envío de información.
Estos son el modo \sphinxstyleemphasis{reliable}, que requiere de una señal de confirmación por parte
del receptor, priorizando la fiabilidad de la comunicación; y el modo \sphinxstyleemphasis{best\sphinxhyphen{}effort},
que trata de enviar la mayor cantidad de mensajes a la mayor velocidad, aunque en
redes poco robustas puede resultar poco fiable.

\sphinxAtStartPar
De este modo, combinando los dos tipos de conexión y los dos tipos de comunicación
se han formado cuatro situaciones que mostraran distintos resultados de los que
extraer conclusiones tras ser comparados.


\section{Herramientas empleadas}
\label{\detokenize{dise_xf1o_del_analisis:herramientas-empleadas}}
\sphinxAtStartPar
La herramienta principal de la que nos serviremos durante la totalidad de la
evaluación será una aplicación que se ha diseñado con el propósito exclusivo
de someter al sistema a distintas situaciones en las que, mediante otras
herramientas, recopilar datos.

\sphinxAtStartPar
La aplicación está programada en C e incluye las librerías de freeRTOS
que proporcionan las funciones propias de micro\sphinxhyphen{}ROS así como los tipos de mensajes
que se van a utilizar.

\sphinxAtStartPar
Esta aplicación será añadida al firmware, compilada y enviada a la placa, donde
se ejecutará periódicamente.

\sphinxAtStartPar
A continuación se muestra el código de la aplicación y posteriormente se procederá
a explicar los aspectos más reseñables del mismo.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}rcl/rcl.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}rcl/error\PYGZus{}handling.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}std\PYGZus{}msgs/msg/string.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}rclc/rclc.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}rclc/executor.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ARRAY\PYGZus{}LEN 1024}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef ESP\PYGZus{}PLATFORM}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}freertos/FreeRTOS.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}freertos/task.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define RCCHECK(fn) \PYGZob{}}
    \PYG{n}{rcl\PYGZus{}ret\PYGZus{}t} \PYG{n}{temp\PYGZus{}rc} \PYG{o}{=} \PYG{n}{fn}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{temp\PYGZus{}rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{RCL\PYGZus{}RET\PYGZus{}OK}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed status on line \PYGZpc{}d: \PYGZpc{}d. Aborting.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{\PYGZus{}\PYGZus{}LINE\PYGZus{}\PYGZus{}}\PYG{p}{,}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{n}{temp\PYGZus{}rc}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{vTaskDelete}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define RCSOFTCHECK(fn) \PYGZob{}}
    \PYG{n}{rcl\PYGZus{}ret\PYGZus{}t} \PYG{n}{temp\PYGZus{}rc} \PYG{o}{=} \PYG{n}{fn}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{temp\PYGZus{}rc} \PYG{o}{!}\PYG{o}{=} \PYG{n}{RCL\PYGZus{}RET\PYGZus{}OK}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed status on line \PYGZpc{}d: \PYGZpc{}d. Continuing.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{\PYGZus{}\PYGZus{}LINE\PYGZus{}\PYGZus{}}\PYG{p}{,}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{n}{temp\PYGZus{}rc}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{rcl\PYGZus{}publisher\PYGZus{}t} \PYG{n}{publisher}\PYG{p}{;}
\PYG{n}{std\PYGZus{}msgs\PYGZus{}\PYGZus{}msg\PYGZus{}\PYGZus{}String} \PYG{n}{msg}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{timer\PYGZus{}callback}\PYG{p}{(}\PYG{n}{rcl\PYGZus{}timer\PYGZus{}t} \PYG{o}{*} \PYG{n}{timer}\PYG{p}{,} \PYG{k+kt}{int64\PYGZus{}t} \PYG{n}{last\PYGZus{}call\PYGZus{}time}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{RCLC\PYGZus{}UNUSED}\PYG{p}{(}\PYG{n}{last\PYGZus{}call\PYGZus{}time}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{timer} \PYG{o}{!}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{RCSOFTCHECK}\PYG{p}{(}\PYG{n}{rcl\PYGZus{}publish}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{publisher}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{msg}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{appMain}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*} \PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{rcl\PYGZus{}allocator\PYGZus{}t} \PYG{n}{allocator} \PYG{o}{=} \PYG{n}{rcl\PYGZus{}get\PYGZus{}default\PYGZus{}allocator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{rclc\PYGZus{}support\PYGZus{}t} \PYG{n}{support}\PYG{p}{;}

    \PYG{c+c1}{// create init\PYGZus{}options}
    \PYG{n}{RCCHECK}\PYG{p}{(}\PYG{n}{rclc\PYGZus{}support\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{support}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{allocator}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// create node}
    \PYG{n}{rcl\PYGZus{}node\PYGZus{}t} \PYG{n}{node}\PYG{p}{;}
    \PYG{n}{RCCHECK}\PYG{p}{(}\PYG{n}{rclc\PYGZus{}node\PYGZus{}init\PYGZus{}default}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{node}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZus{}test\PYGZus{}app\PYGZus{}publisher}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{support}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// create publisher}
    \PYG{n}{RCCHECK}\PYG{p}{(}\PYG{n}{rclc\PYGZus{}publisher\PYGZus{}init\PYGZus{}default}\PYG{p}{(}
        \PYG{o}{\PYGZam{}}\PYG{n}{publisher}\PYG{p}{,}
        \PYG{o}{\PYGZam{}}\PYG{n}{node}\PYG{p}{,}
        \PYG{n}{ROSIDL\PYGZus{}GET\PYGZus{}MSG\PYGZus{}TYPE\PYGZus{}SUPPORT}\PYG{p}{(}\PYG{n}{std\PYGZus{}msgs}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{,} \PYG{n}{String}\PYG{p}{)}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZus{}custom\PYGZus{}publisher}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// create timer,}
    \PYG{n}{rcl\PYGZus{}timer\PYGZus{}t} \PYG{n}{timer}\PYG{p}{;}
    \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{timer\PYGZus{}period} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{RCCHECK}\PYG{p}{(}\PYG{n}{rclc\PYGZus{}timer\PYGZus{}init\PYGZus{}default}\PYG{p}{(}
        \PYG{o}{\PYGZam{}}\PYG{n}{timer}\PYG{p}{,}
        \PYG{o}{\PYGZam{}}\PYG{n}{support}\PYG{p}{,}
        \PYG{n}{RCL\PYGZus{}MS\PYGZus{}TO\PYGZus{}NS}\PYG{p}{(}\PYG{n}{timer\PYGZus{}period}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{timer\PYGZus{}callback}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// create executor}
    \PYG{n}{rclc\PYGZus{}executor\PYGZus{}t} \PYG{n}{executor}\PYG{p}{;}
    \PYG{n}{RCCHECK}\PYG{p}{(}\PYG{n}{rclc\PYGZus{}executor\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{executor}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{support}\PYG{p}{.}\PYG{n}{context}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{allocator}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{RCCHECK}\PYG{p}{(}\PYG{n}{rclc\PYGZus{}executor\PYGZus{}add\PYGZus{}timer}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{executor}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{timer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{msg}\PYG{p}{.}\PYG{n}{data}\PYG{p}{.}\PYG{n}{data} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{char} \PYG{o}{*}\PYG{p}{)} \PYG{n}{malloc} \PYG{p}{(}\PYG{n}{ARRAY\PYGZus{}LEN} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{char}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{msg}\PYG{p}{.}\PYG{n}{data}\PYG{p}{.}\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{msg}\PYG{p}{.}\PYG{n}{data}\PYG{p}{.}\PYG{n}{capacity} \PYG{o}{=} \PYG{n}{ARRAY\PYGZus{}LEN}\PYG{p}{;}

    \PYG{n}{memset}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{data}\PYG{p}{.}\PYG{n}{data}\PYG{p}{,}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{1}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{msg}\PYG{p}{.}\PYG{n}{data}\PYG{p}{.}\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{1024}\PYG{p}{;}

    \PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{rclc\PYGZus{}executor\PYGZus{}spin\PYGZus{}some}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{executor}\PYG{p}{,} \PYG{n}{RCL\PYGZus{}MS\PYGZus{}TO\PYGZus{}NS}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// free resources}
    \PYG{n}{RCCHECK}\PYG{p}{(}\PYG{n}{rcl\PYGZus{}publisher\PYGZus{}fini}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{publisher}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{node}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{RCCHECK}\PYG{p}{(}\PYG{n}{rcl\PYGZus{}node\PYGZus{}fini}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{node}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{vTaskDelete}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
En primer lugar, se añaden todas las librerías que se utilizarán y se definen
las funciones «RCCHECK» y «RCSOFTCHECK». Estas serán de gran utilidad durante
toda la ejecución, ya que se llamarán en el momento de utilizar cualquier otra
función para asegurar su correcto funcionamiento en un tiempo establecido.
De no ser así se generarán distintos mensajes de error e incluso se forzará
la detención de la aplicación en función de la gravedad del fallo. Esto resulta
crucial en aplicaciones de este tipo, ya que un pequeño error en los tiempos
puede resultar muy significativo en sistemas de tiempo real.

\sphinxAtStartPar
Posteriormente, se crea la función «timer\_callback», que se ejecutará
cada vez que el timer llegue a cero. En ella simplemente se publica un mensaje
siempre que el timer siga contando.

\sphinxAtStartPar
Seguidamente, se crean el nodo y el publisher. En la creación del publisher es en
la que se determina tanto la calidad de la comunicación como el tipo de mensaje
que este enviará. En este caso se utiliza la función «rclc\_publisher\_init\_default»,
lo que creará un publisher que actuará bajo el modo \sphinxstyleemphasis{reliable}. Para cambiar al
modo \sphinxstyleemphasis{best\sphinxhyphen{}effort}, sería necesario sustituir esta función por «rclc\_publisher\_init\_best\_effort»,
manteniendo iguales los parámetros de la misma. Como se puede observar, el tipo
de mensaje escogido ha sido una cadena de caracteres o «string». Esto es debido
a la simplicidad que existe para modificar su tamaño y la facilidad de uso.

\sphinxAtStartPar
A continuación, se crean el timer y el executor. Al timer se le asigna el periodo
en la variable «timer\_period». Esta viene determinada en milisegundos, por lo que
en este caso el periodo sería de 1 milisegundo y la frecuencia de 1000 Hz. El
executor es el encargado de que cuando el temporizador baje a 0 se ejecute
la función «timer callback».

\sphinxAtStartPar
Consecutivamente se completa la cadena de caracteres. Primero se reserva
el espacio en memoria que se pretende utilizar y después se rellenan
todos esos caracteres con la función memset. En este caso se han reservado
y rellenado 1024 caracteres, lo que equivale a 1 kilobyte.

\sphinxAtStartPar
Finalmente, se lanza un bucle infinito en el que simplemente se llama a la función
«rclc\_spin\_some», que llamará al executor cada vez que el contador del timer finalice.
Se le ha asignado un «wake up time» de 1000 milisegundos para asegurarse que
siempre se ejecute a pesar de que pueda existir un pequeño delay en el sistema.

\sphinxAtStartPar
Esta aplicación será lanzada numerosas veces, asignando en cada ocasión los
parámetros que se quieran analizar. Cada vez que se modifique la aplicación
será necesario recompilar el firmware.

\sphinxAtStartPar
Una vez diseñada la aplicación es momento de configurar el firmware.

\sphinxAtStartPar
Para ello lo primero que hay que hacer es declarar el modo de conexión que
se quiere establecer. Este se realiza mediante los siguientes comandos.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
ros2 run micro\PYGZus{}ros\PYGZus{}setup configure\PYGZus{}firmware.sh my\PYGZus{}test\PYGZus{}app \PYGZhy{}t serial

ros2 run micro\PYGZus{}ros\PYGZus{}setup configure\PYGZus{}firmware.sh my\PYGZus{}test\PYGZus{}app \PYGZhy{}t udp \PYGZhy{}i \PYG{o}{[}IP\PYG{o}{]} \PYGZhy{}p \PYG{o}{[}port ID\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Mediante el primer comando se establecerá una conexión en serie. En el segundo
comando se configura una conexión vía Wi\sphinxhyphen{}Fi, en el que será necesario añadir
la ip de la conexión y el número de puerto que se pretende utilizar, normalmente
el 8888.

\sphinxAtStartPar
Si se ha seleccionado la conexión inalámbrica se empleará el siguiente comando
para añadir el SSID y la contraseña de nuestra red.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
ros2 run micro\PYGZus{}ros\PYGZus{}setup build\PYGZus{}firmware.sh menuconfig
\end{sphinxVerbatim}

\sphinxAtStartPar
Finalmente se compilará el firmware completo y se enviará a la placa con los
dos siguientes comandos.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
ros2 run micro\PYGZus{}ros\PYGZus{}setup build\PYGZus{}firmware.sh

ros2 run micro\PYGZus{}ros\PYGZus{}setup flash\PYGZus{}firmware.sh
\end{sphinxVerbatim}

\sphinxAtStartPar
En este momento será necesario lanzar el agente de micro\sphinxhyphen{}ROS desde
nuestra máquina. En función de si hemos optado por una conexión en serie
o inalámbrica emplearemos uno de los dos siguientes comandos:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
ros2 run micro\PYGZus{}ros\PYGZus{}agent micro\PYGZus{}ros\PYGZus{}agent serial \PYGZhy{}\PYGZhy{}dev \PYG{o}{[}device ID\PYG{o}{]}

ros2 run micro\PYGZus{}ros\PYGZus{}agent micro\PYGZus{}ros\PYGZus{}agent udp \PYGZhy{}\PYGZhy{}port \PYG{o}{[}port ID\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
El device ID es la identificación de nuestro dispositivo, la cual
se puede averiguar escribiendo \sphinxcode{\sphinxupquote{ls /dev/serial/by\sphinxhyphen{}id/*}} en la línea de
comandos, y el port ID debe ser el mismo que el seleccionado en
la configuración del hardware.

\sphinxAtStartPar
De este modo ya se ejecutará la aplicación y se enviarán los datos
al espacio DDS.

\sphinxAtStartPar
Para medir la latencia es imprescindible escoger y conocer una herramienta
muy precisa. En este caso se va a utilizar Cyclictest, una herramienta de
benchmarking para sistemas en tiempo real. En concreto, sirve para medir la
latencia del sistema. {[}\hyperlink{cite.marco_teorico_y_estado_del_arte:id43}{13}{]}

\sphinxAtStartPar
Un análisis de la latencia puede ser muy distinto de otro dependiendo
de varios factores y las condiciones en las que se quiera realizar
el test. Es por ello por lo que es fundamental configurar bien la herramienta
antes de ser utilizada para obtener unos datos fiables.

\sphinxAtStartPar
En este caso se ha utilizado la siguiente configuración:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
cyclictest \PYGZhy{}D \PYG{l+m}{1} \PYGZhy{}\PYGZhy{}verbose \PYGZhy{}i \PYG{l+m}{100} \PYGZhy{}p \PYG{l+m}{95}
\end{sphinxVerbatim}

\sphinxAtStartPar
El parámetro D indica la duración del test, en este caso de un segundo.
«Verbose» expresa que se produzca una salida detallada de la latencia.
La opción i muestra el tamaño del intervalo entre medidas, en este caso
de 100 micro segundos, por lo que se realizarán un total de 10000 medidas.
Finalmente, p indica la prioridad porcentual de los procesos que ocurran
en tiempo real, en este caso de máxima prioridad.

\sphinxAtStartPar
Estos resultados han sido volcados a un fichero para analizarlos posteriormente.

\sphinxAtStartPar
Se ha lanzado un análisis por cada escenario, estableciendo la frecuencia
en 1000 Hz y el tamaño del mensaje en 1 kilobyte. De este modo, la placa trabajará
bajo una gran demanda, sometiéndola a una situación límite. De esta forma,
podremos observar la evolución de la latencia cuando la placa utiliza
todos sus recursos.

\sphinxAtStartPar
Para medir el throughput se ha utilizado el propio agente de micro\sphinxhyphen{}ROS.
Añadiendo la opción \sphinxhyphen{}v5 después de ejecutar el agente, se muestra por pantalla
los mensajes publicados en el DDS. Se ha decidido volcar la salida por pantalla
en un fichero.

\sphinxAtStartPar
En este ámbito se han realizado 24 mediciones, 6 por cada escenario. En
ellas se ha modificado la frecuencia del envío de mensajes manteniendo
el tamaño del mismo.

\sphinxAtStartPar
La recopilación de cada análisis, ha sido de unos 15 segundos, tiempo
más que suficiente para generar una muestra amplia del número de mensajes
que se ha llegado a publicar por segundo. En la salida
del agente también se muestra el tiempo exacto de la publicación de los
mensajes por lo que simplemente ha sido necesario realizar una media
del número de mensajes publicados por segundo y multiplicarlos por
el tamaño del mensaje.

\sphinxAtStartPar
Seguidamente, la medición de la memoria empleada se ha producido utilizando
el comando \sphinxcode{\sphinxupquote{htop}} de Ubuntu, en el que se muestra el consumo de la memoria
de cada tarea llevada acabo en cada momento.

\sphinxAtStartPar
La influencia de la perturbación en la red se medirá del mismo modo en el que
se ha medido la latencia, pero en este caso solo se utilizaran los escenarios
en los que se emplea la conexión Wi\sphinxhyphen{}Fi, ya que el ordenador empleado solo puede
conectarse al agente creado con un puerto.

\sphinxAtStartPar
Finalmente, cabe destacar que se ha utilizado Jupyter Notebook para
realizar las gráficas y los análisis estadísticos.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=100\sphinxpxdimen]{{jupyter_notebook}.png}
\caption{Logotipo de Jupyter notebook}\label{\detokenize{dise_xf1o_del_analisis:id10}}\end{figure}

\sphinxAtStartPar



\chapter{Resultados}
\label{\detokenize{resultados:resultados}}\label{\detokenize{resultados::doc}}
\sphinxAtStartPar
A continuación, se muestran los resultados de los análisis y una
discusión de estos, además de las conclusiones obtenidas teniendo
en cuenta diferentes factores.


\section{Latencia}
\label{\detokenize{resultados:latencia}}
\sphinxAtStartPar
Seguidamente, se muestran las gráficas de los datos expresadas como densidades de
latencias y un histograma con los datos discretos de todas las latencias.

\sphinxAtStartPar
Observando los resultados durante la recopilación de datos, ha resultado llamativo el hecho de que más del
90\% de las latencias obtenidas se comprenden entre los 3 y los 4
microsegundos. Sin embargo, es un resultado esperado, ya que la frecuencia
con la que se deberían enviar los mensajes es de 1000 Hz (periodo de 1 milisegundo),
y el intervalo de medida de la latencia es de 100 microsegundos (10 veces menor),
por lo que cabe esperar que 9 de cada 10 veces, las latencias producidas sean
de eventos que realiza el sistema simplemente por permanecer encendido.

\sphinxAtStartPar
Esto se ha diseñado de esta manera a propósito, puesto que tras realizar
ensayos previos se ha detectado que las latencias producidas en el sistema oscilaban
entre los 5 y los 50 microsegundos, por lo que con un periodo inferior cabía
la posibilidad de que el delay en el sistema fuera superior al intervalo y la medición
de esta finalizase antes que el propio retraso. Por otra parte, si se aumentaba
en gran medida el intervalo, se corría el riesgo de no registrar las latencias
producidas por algunos eventos.

\sphinxAtStartPar
Es por ello por lo que se ha decidido suprimir en las gráficas las mediciones
de 3 microsegundos, ya que no son relevantes a la hora de analizar el sistema
e impiden observar con claridad el comportamiento de este.


\subsection{Distribución}
\label{\detokenize{resultados:distribucion}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen]{{latency_dist}.png}
\caption{Distribución de latencias}\label{\detokenize{resultados:id2}}\end{figure}

\sphinxAtStartPar
Comparando las cuatro gráficas de las distribuciones de las latencias,
lo primero que resalta a simple vista es el hecho de las gráficas
del mismo modo de conexión tienen una morfología bastante similar.

\sphinxAtStartPar
Las distribuciones de densidades obtenidas mediante la conexión en
serie siguen una curva especialmente regular, con un máximo en una latencia
ligeramente inferior a 5 microsegundos, desde donde la función desciende con una pendiente
prácticamente constante hasta los 7 microsegundos, donde comienza una curva
considerable que produce que la densidad se haga aproximadamente nula a los
10 microsegundos.

\sphinxAtStartPar
Por el contrario, las gráficas resultantes de la conexión Wi\sphinxhyphen{}Fi contienen
una forma peculiarmente irregular. Es cierto que en ambas se sigue alcanzando
el máximo global en una latencia muy similar a las gráficas anteriores. Sin embargo,
se puede observar cómo la pendiente descendente del análisis realizado con conexión
Wi\sphinxhyphen{}Fi y en modo \sphinxstyleemphasis{reliable} está dividida en dos tramos: una primera pendiente muy moderada
hasta los 5 microsegundos seguida de una mucho más brusca que desciende la función desde el
35\% hasta el 7\% de la densidad de la latencia. De la misma manera, el modo \sphinxstyleemphasis{best\sphinxhyphen{}effort} también
presenta un patrón poco reconocible, debido al cambio de tendencia que existe en la función
después de una fuerte bajada. Este punto de inflexión ocurre en torno a los 6 microsegundos y
genera un mínimo relativo para que la curva experimente un ligero remonte hasta los
7.5 microsegundos.

\sphinxAtStartPar
Estas diferencias en las morfologías de las gráficas pueden explicarse entendiendo
que la conexión en serie da lugar a una transmisión de datos más regular que
la conexión inalámbrica.

\sphinxAtStartPar
Por otro lado, también resulta llamativo otro aspecto relacionado con la calidad
del servicio escogida. Las gráficas obtenidas de los experimentos en modo
\sphinxstyleemphasis{reliable} tienen el 40\% de las latencias obtenidas entre los 4 y 5 microsegundos.

\sphinxAtStartPar
Sin embargo, la distribución de las latencias resultantes de las pruebas realizadas
en modo \sphinxstyleemphasis{best\sphinxhyphen{}effort} es mucho más homogénea, teniendo estas su máximo en torno al
27\% y el 32\%. Además, la anchura del pico de las bajas latencias es notablemente
superior, finalizando este prácticamente en los 10 microsegundos, frente a los
7 microsegundos que presentan las gráficas de modo \sphinxstyleemphasis{reliable}.

\sphinxAtStartPar
Estos resultados son muy comprensibles. El modo \sphinxstyleemphasis{best\sphinxhyphen{}effort} permite una comunicación
más fluida, lo que indica que bajo la gran demanda que estaba trabajando la placa,
se envíen más mensajes en el mismo tiempo que en el modo \sphinxstyleemphasis{reliable}. Al llegar más datos
en la misma cantidad de tiempo, el agente tiene una mayor carga de trabajo y realiza
más operaciones, ya que tiene que publicar más mensajes en el DDS.


\subsection{Histograma}
\label{\detokenize{resultados:histograma}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen]{{latency_hist}.png}
\caption{Histogramas de latencias}\label{\detokenize{resultados:id3}}\end{figure}

\sphinxAtStartPar
El histograma de latencias muestra una información similar a la distribución previamente estudiada.

\sphinxAtStartPar
Sin embargo, cabe destacar que en estos diagramas se puede apreciar más fácilmente
cómo la gráfica correspondiente a la conexión en serie con modo \sphinxstyleemphasis{reliable} presenta
el patrón más reconocible, al tratarse de una comunicación más estable y menos saturada;
y cómo la gráfica correspondiente a la conexión vía Wi\sphinxhyphen{}Fi y en modo \sphinxstyleemphasis{best\sphinxhyphen{}effort} forma
una secuencia mucho más irregular, resultado de una conexión más inestable y de
mayor volumen.

\sphinxAtStartPar
Tras analizar estos resultados se llega a la conclusión de que, como era de esperar,
la manera en la que se comunican el cliente y el agente repercute notablemente en la
manera en la que responde el sistema en cierto real.

\sphinxAtStartPar
Es cierto que, a pesar de que un pequeño retraso en el cumplimiento de
una tarea asignada puede ser crítico en el desempeño general del sistema, los retrasos
producidos entre la orden y el cumplimiento del evento en este sistema son prácticamente
despreciables en cualquiera de los cuatro escenarios formados, ya que en su mayoría
no sobrepasan los 15 microsegundos.

\sphinxAtStartPar
Esto es causado principalmente porque el sistema está compuesto por dos componentes con
una diferencia abismal de capacidad de procesamiento. Por un lado, la placa ESP32
es un dispositivo que cuenta con unos recursos extremadamente limitados, cuyo objetivo
no es trabajar con un volumen elevado de datos que puedan suponer un problema en el
rendimiento del sistema, sino establecer una conexión rápida y fiable con un agente
para realizar pequeñas operaciones a una alta velocidad. Por otro lado, se está
utilizando como agente un ordenador de última generación que cuenta con un procesador Intel
de cuatro núcleos, al que una transferencia de datos, que en el caso más optimista
rondaría el megabyte por segundo, no debería afectar en gran medida a su rendimiento.


\subsection{Conclusión}
\label{\detokenize{resultados:conclusion}}
\sphinxAtStartPar
Estas conclusiones muestran las posibilidades que ofrecen este tipo de sistemas en la vida
real. Por una parte, sería muy posible reducir en gran medida la calidad del dispositivo en
la mayoría de aplicaciones, obteniendo igualmente unos resultados sobresalientes. Por
otro lado, también resultaría muy interesante un sistema similar en el que un solo agente
pudiera controlar una gran cantidad de clientes sin verse afectado el rendimiento.

\sphinxAtStartPar
En cualquiera de los escenarios propuestos, los resultados que se han obtenido
en las mediciones de la latencia son fácilmente extrapolables y proporcionan una idea
de las ventajas y limitaciones que tendrían en función de la configuración del
mismo.


\section{Throughput}
\label{\detokenize{resultados:throughput}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen]{{throughput}.png}
\caption{Evolución del throughput}\label{\detokenize{resultados:id4}}\end{figure}

\sphinxAtStartPar
La capacidad de transferencia es un dato muy relevante en estos sistemas,
ya que suponen un indicativo de peso para delimitar las aplicaciones que pueden
llevarse a cabo.

\sphinxAtStartPar
En primer lugar, se puede observar cómo todas las gráficas obtenidas tienden hacia
un valor de throughput. Este valor indica la capacidad de transferencia de datos
de nuestro sistema cuando este se satura, es decir, la teórica máxima tasa de
transferencia.

\sphinxAtStartPar
Sin embargo, como se verá a continuación, esto no siempre es así y existen
excepciones.

\sphinxAtStartPar
Para estimar los valores en los que podía darse el punto de saturación,
se ha utilizado un método de prueba y error en los que se ha repetido el experimento
numerosas veces hasta establecer un intervalo en el que la tasa de transferencia no
aumentaba. De este modo se han establecido unos valores, distintos en cada caso,
para los que tomar datos y observar con precisión el momento de saturación.

\sphinxAtStartPar
A continuación, se va a realizar un análisis detallado de las gráficas obtenidas.

\sphinxAtStartPar
Como ya ocurrió en el análisis de la latencia, un primer aspecto que llama la
atención es la diferencia de morfología que se observa entre las gráficas de las
pruebas realizadas bajo el modo \sphinxstyleemphasis{reliable} y las realizadas con el modo \sphinxstyleemphasis{best\sphinxhyphen{}effort}.

\sphinxAtStartPar
Primeramente, se puede ver cómo en las gráficas del modo \sphinxstyleemphasis{reliable}, la curva
generada es bastante suave y desde un primer momento mantiene una curvatura más o
menos constante.

\sphinxAtStartPar
Sin embargo, en los dos casos del modo \sphinxstyleemphasis{best\sphinxhyphen{}effort} se ve claramente cómo en un determinado
punto, existe un pico que rompe con la continuidad de la gráfica. Esto sucede
en concreto en un punto que, atendiendo a la teoría, debería estar en saturación pero que,
como se puede comprobar, transmite una mayor cantidad de datos de lo previsto.

\sphinxAtStartPar
Esto solo ocurre en una frecuencia ligeramente superior a la que en teoría sería
la frecuencia que produzca la saturación, ya que en la siguiente recopilación de
datos, la tasa de transferencia efectiva disminuye hasta el punto que corresponde con
el límite al que tiende la función.

\sphinxAtStartPar
Estos resultados resultan muy interesantes ya que indican que el modo \sphinxstyleemphasis{best\sphinxhyphen{}effort}
no cuenta con una gran ventaja frente a altos volúmenes de demanda, sino que, en puntos
cercanos al límite del throughput, existe un intervalo en el que la comunicación
funciona a un mejor nivel que cuando el sistema se satura.

\sphinxAtStartPar
Esto puede resultar muy conveniente en aplicaciones diseñadas para que el sistema
funcione cerca de su punto de saturación, ya que si en un momento determinado se produce
un pico en la demanda, este modo de comunicación otorga una mayor garantía de que
esta se pueda satisfacer.

\sphinxAtStartPar
Por otro lado, atendiendo al método de conexión, existe otra notable diferencia. El
orden de magnitud del throughput es completamente distinto. En la conexión en serie
el límite de envío de datos por segundo tiende en ambos casos a 5 kilobytes por segundo.
Por el contrario, en conexión vía Wi\sphinxhyphen{}Fi, esta cifra aumenta hasta casi los 60 kilobytes
por segundo. Esto supone una diferencia abismal entre ambos métodos de conexión, la cual
puede limitar enormemente las aplicaciones en un sistema conectado en serie.

\sphinxAtStartPar
Esto puede resultar anti\sphinxhyphen{}intuitivo ya que se puede llegar a pensar que una conexión
en serie siempre va a proporcionar más garantías que una conexión inalámbrica, como ocurre
por ejemplo con la conexión a internet vía cable Ethernet frente a conexión
Wi\sphinxhyphen{}Fi. Sin embargo, en este caso los métodos de conexión son más independientes y,
teniendo en cuenta que la conexión vía Wi\sphinxhyphen{}Fi es uno de los principales distintivos
que proporciona la placa escogida, esta resulta estar más optimizada que una conexión
en serie convencional.

\sphinxAtStartPar
En relación con el modo de comunicación, también existe una ligera diferencia en el límite
del throughput, sin embargo esta es apenas apreciable y no es significativa frente a la
diferencia existente con el método de conexión.


\subsection{Conclusión}
\label{\detokenize{resultados:id1}}
\sphinxAtStartPar
En definitiva, las tasas de transferencia obtenidas son de unos 60 kilobytes por segundo
para conexiones vía Wi\sphinxhyphen{}Fi y de unos 5 kilobytes por segundo con una conexión en serie.
Esto supone una diferencia significativa, sin embargo, en ninguno de los dos casos
se trata de una tasa muy elevada teniendo en cuenta la capacidad de transferencia que
permite la tecnología de hoy en día.

\sphinxAtStartPar
Esto remarca una vez más el objetivo principal del software que se está estudiando,
aportar una forma sencilla de conectar y programar varios dispositivos con recursos limitados
para que realicen tareas básicas.


\section{Consumo de memoria}
\label{\detokenize{resultados:consumo-de-memoria}}
\sphinxAtStartPar
Tras haber realizado ya las mediciones de la latencia del sistema y del throughput,
una de las conclusiones obtenidas indica que el verdadero propósito del sistema no
reside en realizar tareas que requieran mucha potencia sino la fiabilidad y la velocidad
de realizar tareas más modestas.

\sphinxAtStartPar
El consumo de memoria que se ha medido no hace más que reforzar dicha conclusión ya que,
en los cuatro escenarios el consumo de la memoria apenas se ha notado.

\sphinxAtStartPar
En todos las pruebas hemos obtenido un consumo de la memoria de tan solo un 2\%, algo
que se considera despreciable frente al consumo de memoria de la mayoría de procesos que
realiza el ordenador empleado.


\section{Influencia de interferencias}
\label{\detokenize{resultados:influencia-de-interferencias}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen]{{interferencias}.png}
\caption{Influencia de las interferencias}\label{\detokenize{resultados:id5}}\end{figure}

\sphinxAtStartPar
Lo primero que hay que tener en cuenta es el hecho de que en una aplicación
real es muy probable que existan perturbaciones en la red que alteren el
comportamiento de nuestro sistema, por lo que es importante que el diseño de este
tenga en cuenta dichos escenarios.

\sphinxAtStartPar
Inicialmente, lo que más llama la atención al observar las gráficas es que estas forman
un pico bastante más ancho que las obtenidas previamente. Esto es un resultado
esperado ya que es lógico deducir que al añadirle carga al sistema este tarde más
en realizar todo tipo de tareas.

\sphinxAtStartPar
Seguidamente, lo que vemos es que las gráficas de ambos modos tienen una irregularidad
similar al experimento realizado sin interferencias, pero aún más pronunciada.
Al estar corriendo otro proceso en paralelo es entendible que ambos procesos no esten
sincronizados y se prolongue la irregularidad que ya presentaba la conexión vía Wi\sphinxhyphen{}Fi.

\sphinxAtStartPar
Resulta interesante el hecho de que la morfología de las gráficas sea muy parecida a las obtenidas
en el experimento sin perturbaciones. Esto dota al análisis de una mayor fiabilidad y permite
realizar predicciones de cómo el sistema podría responder en otras situaciones.

\sphinxAtStartPar
Por último, es preciso señalar que, a pesar que no se vea reflejado en las gráficas, la cantidad
de veces que la latencia ha sido 3 en este último experimento (tomada como latencia
referencia del sistema) ha resultado superior en ambos casos frente a las gráficas
sin perturbaciones, un dato que nos confirma la mayor demanda de recursos que se
prevía.

\sphinxAtStartPar
De todos modos, la latencia resultante sigue siendo poco significativa en el sistema,
teniendo aún un margen bastante amplio para añadir clientes al mismo agente.


\chapter{Conclusiones y líneas futuras}
\label{\detokenize{conclusiones_y_lineas_futuras:conclusiones-y-lineas-futuras}}\label{\detokenize{conclusiones_y_lineas_futuras::doc}}

\section{Conclusiones}
\label{\detokenize{conclusiones_y_lineas_futuras:conclusiones}}
\sphinxAtStartPar
Tras varios meses realizando el trabajo se han obtenido numerosas
conclusiones, tanto durante en el proceso de aprendizaje como
en el momento de la realización de análisis y la discusión de los
resultados.

\sphinxAtStartPar
Lo primero, que resulta llamativo a la hora de introducirse en la
programación de sistemas que operen en tiempo real es la complejidad
que conlleva diseñar un software de este tipo. A la hora de diseñar la
arquitectura del sistema, es crucial que los componentes del
software mantengan una comunicación fiable que no se vea afectada
en gran medida por las perturbaciones que puedan existir en el
entorno del sistema y que la transmisión de información se ejecute
de una manera regular. Esto se consigue dividiendo la arquitectura
general en distintos niveles que se encargan del funcionamiento
de una sección específica de la comunicación.

\sphinxAtStartPar
En este sentido, ROS consigue unificar todas las partes que tratan
la información en un solo software para permitir al usuario centrarse
en el desarrollo de aplicaciones.

\sphinxAtStartPar
Por otro lado es reseñable la evolución que ha experimentado este
sector en los últimos años. Su comienzo se dio hace poco más de
una década y durante este tiempo se han realizado numerosos proyectos y
se ha logrado desarrollar una segunda versión que incorpora una
gran cantidad de mejoras y que se actualiza constantemente con
nuevas distribuciones.

\sphinxAtStartPar
Esto muestra claramente el apoyo que existe hacia el sector y
las enormes previsiones que este posee de cara a un futuro
cercano.

\sphinxAtStartPar
En este sentido micro\sphinxhyphen{}ROS supone un gran avance para el sector. El desarrollo
de una variante del sistema operativo de robots que permite operar con dispositivos
de tan reducido coste se traduce en oportunidades para permitir que cualquier
persona pueda introducirse en el mundo de la programación de robots sin
necesidad de un gran presupuesto. Asimismo, resulta fascinante el modo en el
que, a pesar de no existir aún una gran cantidad de información en la web sobre el
desarrollo de aplicaciones en micro\sphinxhyphen{}ROS, este cuenta con una comunidad muy activa
que favorece a los usuarios menos experimentados. Durante la realización del
trabajo han ocurrido situaciones de bloqueo en las que ha sido necesario
utilizar información que apenas llevaba horas publicada en la red. Esto muestra
una idea del potencial y del margen de mejora que tiene a día de hoy.

\sphinxAtStartPar
En cuanto a la actuación del software, ha resultado muy interesante el hecho
de poder obtener unos resultados tan concluyentes empleando una aplicación
relativamente sencilla y una placa que actúa con unos recursos tan limitados.

\sphinxAtStartPar
De este modo, los análisis que se han discutido previamente muestran
una idea general del alcance de este software. Es cierto que numéricamente
hablando pueda parecer que no cuenta con la potencia necesaria para
soportar aplicaciones que vayan a ser realizadas por robots en tiempo real.

\sphinxAtStartPar
Sin embargo, el gran potencial de estos sistemas no es el poder desarrollar
complejas aplicaciones para la monitorización de un gran robot, sino la facilidad
de poder fragmentar un gran sistema en distintos apartados que estén
controlados por dispositivos más modestos que sean diseñados específicamente
para la tarea que vayan a desempeñar.

\sphinxAtStartPar
Teniendo esto en cuenta, el proyecto realizado muestra unos resultados satisfactorios
que se resumen en cómo la complejidad de una tecnología tan avanzada se consigue
simplificar de tal forma, manteniendo unas prestaciones más que suficientes
para los objetivos para los que están diseñados la mayoría de microcontroladores.


\section{Lineas futuras}
\label{\detokenize{conclusiones_y_lineas_futuras:lineas-futuras}}
\sphinxAtStartPar
Para los análisis que se han realizado en este trabajo se han seleccionado unos
parámetros y distintos escenarios. Estos nos muestran una idea bastante acertada
de cómo se comporta la placa. Sin embargo, existen muchas otras variables que no
se han medido que aportarían bastante información, como puede ser la latencia que
se produce en el transporte del mensaje desde el cliente al agente, la CPU que se
emplea en el proceso, etc.

\sphinxAtStartPar
Asimismo, sería muy interesante repetir los experimentos que se han realizado
teniendo varias placas conectadas como suscriptoras del topic. De este modo,
se podría comprobar las características de la conexión en un entorno más
cercano a un posible escenario de la vida real.

\sphinxAtStartPar
Otro posible análisis podría centrarse en la comparación de resultados entre distintos
tipos de hardware o distintos RTOS. Esto resultaría muy útil a la hora de escoger
tanto la placa como el sistema operativo que la soporta.

\sphinxAtStartPar
Finalmente, cabe recordar que la ciencia que se ha estudiado está en pleno desarrollo
y sufre cambios constantemente, por lo que no sería de extrañar que de aquí a unos
pocos años, o incluso meses, se optimice la calidad de la conexión de algunos
de los componentes que forman tanto el software como el hardware. En cualquier caso, es
muy probable que en un breve espacio de tiempo surjan numerosas mejoras.


\chapter{Planificación temporal y presupuesto}
\label{\detokenize{planificacion_temporal_y_presupuesto:planificacion-temporal-y-presupuesto}}\label{\detokenize{planificacion_temporal_y_presupuesto::doc}}

\section{Planificación temporal}
\label{\detokenize{planificacion_temporal_y_presupuesto:planificacion-temporal}}
\sphinxAtStartPar
A continuación se muestra el diagrama de Gantt de las actividades
llevadas a cabo durante la realización del trabajo. Las fechas
tienen una fecha y duración aproximada.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{Diagrama_de_Gantt}.png}
\caption{Diagrama de Gantt}\label{\detokenize{planificacion_temporal_y_presupuesto:id1}}\end{figure}

\sphinxAtStartPar
Aunque no es apreciable en el diagrama, la carga de trabajo ha sido
muy variable durante toda la duración del ejercicio, siendo muy
superior durante los meses de septiembre y octubre frente a
julio y agosto.


\section{Presupuesto}
\label{\detokenize{planificacion_temporal_y_presupuesto:presupuesto}}
\sphinxAtStartPar
En la siguiente tabla se muestra una estimación del coste total
que ha supuesto el trabajo. En él se ha estimado que cada hora
empleada por el tutor se valora en 40 euros y cada hora empleada
por el alumno tiene un valor de 15 euros. Además se ha incluido
un coste de los equipos informáticos utilizados, puesto que aunque
ya se tuvieran antes del comienzo del trabajo, durante el mismo se
ha producido un desgaste debido a la gran cantidad de horas que
se han utilizado.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{Presupuesto}.PNG}
\caption{Presupuesto}\label{\detokenize{planificacion_temporal_y_presupuesto:id2}}\end{figure}

\sphinxAtStartPar
En este sentido, el valor total que se le asigna a la realizacion
del trabajo es de 5.471 euros. Esta cifra es un valor aproximado
pero que muestra una buena representación de lo que podría
equivaler en relación con una investigación profesional.


\chapter{Impacto social y medioambiental}
\label{\detokenize{impacto_social_y_medioambiental:impacto-social-y-medioambiental}}\label{\detokenize{impacto_social_y_medioambiental::doc}}
\sphinxAtStartPar
En primer lugar, es necesario diferenciar entre impacto social directo e indirecto.
El impacto directo se relaciona con la manera en la que los resultados o las conclusiones
obtenidas pueden afectar directamente a la sociedad o al medioambiente, mientras que el impacto indirecto tiene
que ver con los efectos que se puedan mostrar a largo plazo relacionados con los avances tecnológicos
a los que pueda contribuir este trabajo.


\section{Impacto social}
\label{\detokenize{impacto_social_y_medioambiental:impacto-social}}
\sphinxAtStartPar
El impacto social directo de la totalidad del proyecto no es muy elevado, ya que
directamente no proporciona ninguna herramienta que sea de gran utilidad
para un usuario medio. Sin embargo, los efectos de este trabajo de investigación
si pueden resultar relevantes para las entedidas que participen en el desarrollo de
software de control de robots en tiempo real o en fabricantes de placas de desarrollo,
pudiendo utilizar varios resultados de los obtenidos como referencia a la hora
de establecer sus especificaciones.

\sphinxAtStartPar
Este trabajo contribuye al avance en el desarrollo de la tecnología relacionada con
la industria 4.0 y el IoT. En este sentido, el impacto social indirecto que es capaz
de producir este proyecto puede convertirse en algo muy notable, ya que, la revolución
tecnológica que este fenómeno va a producir, va a afectar radicalmente en la vida de
las personas. Estos cambios supondran un aumento general en la calidad de vida de la
sociedad, reflejado en la automatización de numerosas tareas rutinarias, el ahorro
de recursos y una nueva manera de trabajar mucho más eficiente.


\section{Impacto medioambiental}
\label{\detokenize{impacto_social_y_medioambiental:impacto-medioambiental}}
\sphinxAtStartPar
La cantidad de recursos consumidos durante la realización de pruebas y la ejecución
de los análisis es bastante reducida. Esto es así ya que el sistema que se ha formado está formado
simplemente por un ordenador personal de última generación, que no consume gran cantidad
de energía, y una placa que está diseñada expresamente de modo que economice los recursos
al máximo, por lo que su consumo de energía es prácticamente irrelevante.

\sphinxAtStartPar
En lo relacionado con el impacto medioambiental indirecto, como ya se ha visto en la
sección anterior, este trabajo supone un avance en la cuarta revolución industrial.
A día de hoy es complicado saber exactamente el modo en el que este fenómeno afectará
al medioambiente, sin embargo, es seguro que esta industria traerá consigo
numerosas tecnologías que contribuyan en el ahorro energético. De este modo, el potencial
impacto indirecto que puede provocar este trabajo resultaría muy positivo.


\chapter{Anexos}
\label{\detokenize{Anexos:anexos}}\label{\detokenize{Anexos::doc}}

\section{Anexo 1: Muestra de resultados obtenidos}
\label{\detokenize{Anexos:anexo-1-muestra-de-resultados-obtenidos}}
\sphinxAtStartPar
A continuación se expone una muestra de los resultados obtenidos
de los análisis realizados.

\sphinxAtStartPar
Latencia:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
Thread \PYG{l+m}{0} Interval: \PYG{l+m}{600}
    \PYG{l+m}{0}:       \PYG{l+m}{0}:      \PYG{l+m}{12}
    \PYG{l+m}{0}:       \PYG{l+m}{1}:       \PYG{l+m}{8}
    \PYG{l+m}{0}:       \PYG{l+m}{2}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:       \PYG{l+m}{3}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:       \PYG{l+m}{4}:      \PYG{l+m}{10}
    \PYG{l+m}{0}:       \PYG{l+m}{5}:       \PYG{l+m}{8}
    \PYG{l+m}{0}:       \PYG{l+m}{6}:       \PYG{l+m}{8}
    \PYG{l+m}{0}:       \PYG{l+m}{7}:       \PYG{l+m}{9}
    \PYG{l+m}{0}:       \PYG{l+m}{8}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:       \PYG{l+m}{9}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{10}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{11}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{12}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{13}:       \PYG{l+m}{9}
    \PYG{l+m}{0}:      \PYG{l+m}{14}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{15}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{16}:       \PYG{l+m}{9}
    \PYG{l+m}{0}:      \PYG{l+m}{17}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{18}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{19}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{20}:      \PYG{l+m}{10}
    \PYG{l+m}{0}:      \PYG{l+m}{21}:       \PYG{l+m}{8}
    \PYG{l+m}{0}:      \PYG{l+m}{22}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{23}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{24}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{25}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{26}:       \PYG{l+m}{9}
    \PYG{l+m}{0}:      \PYG{l+m}{27}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{28}:       \PYG{l+m}{7}
    \PYG{l+m}{0}:      \PYG{l+m}{29}:       \PYG{l+m}{6}
\end{sphinxVerbatim}

\sphinxAtStartPar
Throughput:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYGZca{}\PYG{o}{[}\PYG{o}{[}35m\PYG{o}{[}\PYG{l+m}{1635685759}.599018\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m debug    \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}34mSerialAgentLinux.cpp\PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}37msend\PYGZus{}message            \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}33m\PYG{o}{[}** \PYG{l+s}{\PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.051717]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER} \PYGZlt{}\PYGZlt{}\PYG{o}{=}\PYG{o}{=}\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m        \PYG{p}{|} client\PYGZus{}key: 0x262A35A2, len: \PYG{l+m}{508}
\PYGZca{}\PYG{o}{[}\PYG{o}{[}35m\PYG{o}{[}\PYG{l+m}{1635685760}.051991\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m debug    \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}34mSerialAgentLinux.cpp\PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}37msend\PYGZus{}message            \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}33m\PYG{o}{[}** \PYG{l+s}{\PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.095816]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER} \PYGZlt{}\PYGZlt{}\PYG{o}{=}\PYG{o}{=}\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m        \PYG{p}{|} client\PYGZus{}key: 0x262A35A2, len: \PYG{l+m}{508}
\PYGZca{}\PYG{o}{[}\PYG{o}{[}35m\PYG{o}{[}\PYG{l+m}{1635685760}.096039\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m debug    \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}34mSerialAgentLinux.cpp\PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}37msend\PYGZus{}message            \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}33m\PYG{o}{[}** \PYG{l+s}{\PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.097978]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER} \PYGZlt{}\PYGZlt{}\PYG{o}{=}\PYG{o}{=}\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m        \PYG{p}{|} client\PYGZus{}key: 0x262A35A2, len: \PYG{l+m}{52}
\PYGZca{}\PYG{o}{[}\PYG{o}{[}35m\PYG{o}{[}\PYG{l+m}{1635685760}.098142\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m debug    \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}34mDataWriter.cpp    \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}37mwrite                   \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}33m\PYG{o}{[}** \PYG{l+s}{\PYGZlt{}\PYGZlt{}DDS\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x00000000, len: 1033}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.098277]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37msend\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[** \PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.552689]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER \PYGZlt{}\PYGZlt{}==]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 508}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.552845]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37msend\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[** \PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.596692]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER \PYGZlt{}\PYGZlt{}==]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 508}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.596904]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37msend\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[** \PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.599166]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER \PYGZlt{}\PYGZlt{}==]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 52}
\PYG{l+s}{\PYGZca{}[[35m[1635685760.599352]\PYGZca{}[[m debug    | \PYGZca{}[[34mDataWriter.cpp    \PYGZca{}[[m | \PYGZca{}[[37mwrite                   \PYGZca{}[[m | \PYGZca{}[[33m[** \PYGZlt{}\PYGZlt{}DDS}\PYGZgt{}\PYGZgt{} **\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m        \PYG{p}{|} client\PYGZus{}key: 0x00000000, len: \PYG{l+m}{1033}
\PYGZca{}\PYG{o}{[}\PYG{o}{[}35m\PYG{o}{[}\PYG{l+m}{1635685760}.599486\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m debug    \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}34mSerialAgentLinux.cpp\PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}37msend\PYGZus{}message            \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}33m\PYG{o}{[}** \PYG{l+s}{\PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685761.057626]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER} \PYGZlt{}\PYGZlt{}\PYG{o}{=}\PYG{o}{=}\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m        \PYG{p}{|} client\PYGZus{}key: 0x262A35A2, len: \PYG{l+m}{508}
\PYGZca{}\PYG{o}{[}\PYG{o}{[}35m\PYG{o}{[}\PYG{l+m}{1635685761}.057882\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m debug    \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}34mSerialAgentLinux.cpp\PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}37msend\PYGZus{}message            \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}33m\PYG{o}{[}** \PYG{l+s}{\PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685761.102167]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER} \PYGZlt{}\PYGZlt{}\PYG{o}{=}\PYG{o}{=}\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m        \PYG{p}{|} client\PYGZus{}key: 0x262A35A2, len: \PYG{l+m}{508}
\PYGZca{}\PYG{o}{[}\PYG{o}{[}35m\PYG{o}{[}\PYG{l+m}{1635685761}.102401\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m debug    \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}34mSerialAgentLinux.cpp\PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}37msend\PYGZus{}message            \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}33m\PYG{o}{[}** \PYG{l+s}{\PYGZlt{}\PYGZlt{}SER\PYGZgt{}\PYGZgt{} **]\PYGZca{}[[m        | client\PYGZus{}key: 0x262A35A2, len: 13}
\PYG{l+s}{\PYGZca{}[[35m[1635685761.104181]\PYGZca{}[[m debug    | \PYGZca{}[[34mSerialAgentLinux.cpp\PYGZca{}[[m | \PYGZca{}[[37mrecv\PYGZus{}message            \PYGZca{}[[m | \PYGZca{}[[33m[==\PYGZgt{}\PYGZgt{} SER} \PYGZlt{}\PYGZlt{}\PYG{o}{=}\PYG{o}{=}\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m        \PYG{p}{|} client\PYGZus{}key: 0x262A35A2, len: \PYG{l+m}{52}
\PYGZca{}\PYG{o}{[}\PYG{o}{[}35m\PYG{o}{[}\PYG{l+m}{1635685761}.104368\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m debug    \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}34mDataWriter.cpp    \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}37mwrite                   \PYGZca{}\PYG{o}{[}\PYG{o}{[}m \PYG{p}{|} \PYGZca{}\PYG{o}{[}\PYG{o}{[}33m\PYG{o}{[}** \PYGZlt{}\PYGZlt{}DDS\PYGZgt{}\PYGZgt{} **\PYG{o}{]}\PYGZca{}\PYG{o}{[}\PYG{o}{[}m        \PYG{p}{|} client\PYGZus{}key: 0x00000000, len: \PYG{l+m}{1033}
\end{sphinxVerbatim}

\newpage

\sphinxAtStartPar
Consumo de memoria:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{consumo_de_memoria}.png}
\caption{Resultados de «htop» al ejecutar la aplicación}\label{\detokenize{Anexos:id4}}\end{figure}

\newpage


\section{Anexo 2: Script de python para la generación de gráficas}
\label{\detokenize{Anexos:anexo-2-script-de-python-para-la-generacion-de-graficas}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{k+kn}{from} \PYG{n+nn}{gc} \PYG{k+kn}{import} \PYG{n}{collect}
\PYG{k+kn}{import} \PYG{n+nn}{seaborn} \PYG{k+kn}{as} \PYG{n+nn}{sns}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k+kn}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{sns}\PYG{o}{.}\PYG{n}{set\PYGZus{}theme}\PYG{p}{(}\PYG{n}{style}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{darkgrid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{gen\PYGZus{}plot\PYGZus{}for\PYGZus{}latency}\PYG{p}{(}\PYG{n}{data\PYGZus{}file}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}
        \PYG{n}{data\PYGZus{}file} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{n}{skiprows}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}
        \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{s+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{n}{header}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}
        \PYG{n}{usecols}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{names}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{engine}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{python}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{p}{)}

    \PYG{n}{latency\PYGZus{}df} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{drop}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{n}{df}\PYG{o}{.}\PYG{n}{latency} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{)}

    \PYG{n}{sns}\PYG{o}{.}\PYG{n}{displot}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{latency\PYGZus{}df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kde}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{data\PYGZus{}file} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}dist\PYGZus{}kde.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{)}

    \PYG{n}{sns}\PYG{o}{.}\PYG{n}{histplot}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{latency\PYGZus{}df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{discrete}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{data\PYGZus{}file} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}hist.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{gen\PYGZus{}plot\PYGZus{}for\PYGZus{}tp}\PYG{p}{(}\PYG{n}{data\PYGZus{}info}\PYG{p}{,} \PYG{n}{axes}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data\PYGZus{}file}\PYG{p}{,} \PYG{n}{description}\PYG{p}{,} \PYG{n}{fil}\PYG{p}{,} \PYG{n}{col} \PYG{o}{=} \PYG{n}{data\PYGZus{}info}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{data\PYGZus{}file} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{s+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{rel} \PYG{o}{=} \PYG{n}{sns}\PYG{o}{.}\PYG{n}{relplot}\PYG{p}{(}
        \PYG{n}{ax}\PYG{o}{=}\PYG{n}{axes}\PYG{p}{[}\PYG{n}{fil}\PYG{p}{,} \PYG{n}{col}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{x}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Frequency}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Throughput}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{n}{data}\PYG{o}{=}\PYG{n}{df}\PYG{p}{,}
        \PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{line}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{o}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xscale}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{log}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{base}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{data\PYGZus{}file} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{)}


\PYG{n}{data\PYGZus{}files} \PYG{o}{=} \PYG{p}{[}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency\PYGZus{}serial\PYGZus{}best\PYGZhy{}effort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency\PYGZus{}serial\PYGZus{}reliable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency\PYGZus{}wifi\PYGZus{}best\PYGZhy{}effort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency\PYGZus{}wifi\PYGZus{}reliable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency\PYGZus{}best\PYGZus{}effort\PYGZus{}Wi\PYGZhy{}Fi\PYGZus{}interference}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{latency\PYGZus{}reliable\PYGZus{}Wi\PYGZhy{}Fi\PYGZus{}interference}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{p}{]}


\PYG{k}{for} \PYG{n}{data\PYGZus{}file} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}files}\PYG{p}{:}
    \PYG{n}{gen\PYGZus{}plot\PYGZus{}for\PYGZus{}latency}\PYG{p}{(}\PYG{n}{data\PYGZus{}file}\PYG{p}{)}

\PYG{n}{data\PYGZus{}infos} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{throughput\PYGZus{}serial\PYGZus{}best\PYGZus{}effort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Conexión en serie, modo best\PYGZhy{}effort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{throughput\PYGZus{}serial\PYGZus{}reliable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Conexión en serie, modo reliable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{throughput\PYGZus{}wifi\PYGZus{}best\PYGZus{}effort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Conexión Wi\PYGZhy{}Fi, modo best\PYGZhy{}effort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{throughput\PYGZus{}wifi\PYGZus{}reliable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Conexión Wi\PYGZhy{}Fi, modo reliable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}


\PYG{k}{for} \PYG{n}{data\PYGZus{}info} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}infos}\PYG{p}{:}
    \PYG{n}{fig}\PYG{p}{,} \PYG{n}{axes} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{gen\PYGZus{}plot\PYGZus{}for\PYGZus{}tp}\PYG{p}{(}\PYG{n}{data\PYGZus{}info}\PYG{p}{,} \PYG{n}{axes}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage


\section{Anexo 3: Inciencias ocurridas}
\label{\detokenize{Anexos:anexo-3-inciencias-ocurridas}}
\sphinxAtStartPar
Durante la preparación de los análisis ha sido necesario realizar
numerosas pruebas intermedias que asegurasen el correcto funcionamiento
del hardware y de los middlewares. En la ejecución de estas pruebas
se han encontrado varias incidencias que han ralentizado la realización
del ejercicio.


\subsection{Conexión Wi\sphinxhyphen{}Fi}
\label{\detokenize{Anexos:conexion-wi-fi}}
\sphinxAtStartPar
En primer lugar, surgió un percance durante el intento de realizar
una primera conexión vía Wi\sphinxhyphen{}Fi. Una vez configurado el firmware para
que se conectase a la IP de la red elegida, tras flashear el firmware
en el dispositivo, el punto de acceso Wi\sphinxhyphen{}Fi no lo detectaba. Se utilizó
entonces el siguiente comando para depurar el problema:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
ros2 run micro\PYGZus{}ros\PYGZus{}setup build\PYGZus{}firmware.sh monitor
\end{sphinxVerbatim}

\sphinxAtStartPar
Obteniendo la siguiente información relevante:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
I \PYG{o}{(}\PYG{l+m}{642}\PYG{o}{)} wifi station: ESP\PYGZus{}WIFI\PYGZus{}MODE\PYGZus{}STA
I \PYG{o}{(}\PYG{l+m}{662}\PYG{o}{)} wifi:wifi driver task: 3ffc4398, prio:23, stack:6656, \PYG{n+nv}{core}\PYG{o}{=}\PYG{l+m}{0}
I \PYG{o}{(}\PYG{l+m}{662}\PYG{o}{)} system\PYGZus{}api: Base MAC address is not set, \PYG{n+nb}{read} default base MAC address from BLK0 of EFUSE
I \PYG{o}{(}\PYG{l+m}{662}\PYG{o}{)} system\PYGZus{}api: Base MAC address is not set, \PYG{n+nb}{read} default base MAC address from BLK0 of EFUSE
I \PYG{o}{(}\PYG{l+m}{692}\PYG{o}{)} wifi:wifi firmware version: 3ea4c76
I \PYG{o}{(}\PYG{l+m}{692}\PYG{o}{)} wifi:config NVS flash: enabled
I \PYG{o}{(}\PYG{l+m}{692}\PYG{o}{)} wifi:config nano formating: disabled
I \PYG{o}{(}\PYG{l+m}{692}\PYG{o}{)} wifi:Init dynamic tx buffer num: \PYG{l+m}{32}
I \PYG{o}{(}\PYG{l+m}{702}\PYG{o}{)} wifi:Init data frame dynamic rx buffer num: \PYG{l+m}{32}
I \PYG{o}{(}\PYG{l+m}{702}\PYG{o}{)} wifi:Init management frame dynamic rx buffer num: \PYG{l+m}{32}
I \PYG{o}{(}\PYG{l+m}{712}\PYG{o}{)} wifi:Init management short buffer num: \PYG{l+m}{32}
I \PYG{o}{(}\PYG{l+m}{712}\PYG{o}{)} wifi:Init static rx buffer size: \PYG{l+m}{1600}
I \PYG{o}{(}\PYG{l+m}{712}\PYG{o}{)} wifi:Init static rx buffer num: \PYG{l+m}{10}
I \PYG{o}{(}\PYG{l+m}{722}\PYG{o}{)} wifi:Init dynamic rx buffer num: \PYG{l+m}{32}

Brownout detector was triggered
\end{sphinxVerbatim}

\sphinxAtStartPar
Investigando el último mensaje de error “Brownout detector was triggered”,
se descubrió que la incidencia estaba relacionada con la falta de potencia en
la alimentación de la placa. %
\begin{footnote}[1]\sphinxAtStartFootnote
Expressif. Brownout detector was triggered. URL: \sphinxurl{(https://www.esp32.com/viewtopic.php?t=16299)}.
%
\end{footnote}

\sphinxAtStartPar
En una primera instancia se trató de modificar la fuente de alimentación,
cambiando en primer lugar de puerto en el ordenador y, posteriormente,
conectando la placa directamente a la red de alimentación doméstica. En
ambos casos no se consiguió establecer la conexión Wi\sphinxhyphen{}Fi, manteniéndose el
mismo error en la salida del terminal. Posteriormente se detectó que la
incidencia residía en el cable micro\sphinxhyphen{}USB escogido inicialmente. Este no
conseguía aportar toda la potencia que requiere la placa para establecer
una conexión Wi\sphinxhyphen{}Fi, ya que esta función demanda una mayor cantidad de energía
frente a otras como puede ser la conexión en serie.

\sphinxAtStartPar
Finalmente, se escogió un cable micro USB de calidad superior y se
volvió a utilizar el mimo comando para comprobar la conexión, obteniendo
la siguiente salida:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+go}{I (642) wifi station: ESP\PYGZus{}WIFI\PYGZus{}MODE\PYGZus{}STA}
\PYG{g+go}{I (662) wifi:wifi driver task: 3ffc4398, prio:23, stack:6656, core=0}
\PYG{g+go}{I (662) system\PYGZus{}api: Base MAC address is not set, read default base MAC address from BLK0 of EFUSE}
\PYG{g+go}{I (662) system\PYGZus{}api: Base MAC address is not set, read default base MAC address from BLK0 of EFUSE}
\PYG{g+go}{I (692) wifi:wifi firmware version: 3ea4c76}
\PYG{g+go}{I (692) wifi:config NVS flash: enabled}
\PYG{g+go}{I (692) wifi:config nano formating: disabled}
\PYG{g+go}{I (692) wifi:Init dynamic tx buffer num: 32}
\PYG{g+go}{I (702) wifi:Init data frame dynamic rx buffer num: 32}
\PYG{g+go}{I (702) wifi:Init management frame dynamic rx buffer num: 32}
\PYG{g+go}{I (712) wifi:Init management short buffer num: 32}
\PYG{g+go}{I (712) wifi:Init static rx buffer size: 1600}
\PYG{g+go}{I (712) wifi:Init static rx buffer num: 10}
\PYG{g+go}{I (722) wifi:Init dynamic rx buffer num: 32}
\PYG{g+go}{I (822) phy: phy\PYGZus{}version: 4180, cb3948e, Sep 12 2019, 16:39:13, 0, 0}
\PYG{g+go}{I (822) wifi:mode : sta (e8:68:e7:30:2e:5c)}
\PYG{g+go}{I (822) wifi station: wifi\PYGZus{}init\PYGZus{}sta finished.}
\PYG{g+go}{I (942) wifi:new:\PYGZlt{}6,0\PYGZgt{}, old:\PYGZlt{}1,0\PYGZgt{}, ap:\PYGZlt{}255,255\PYGZgt{}, sta:\PYGZlt{}6,0\PYGZgt{}, prof:1}
\PYG{g+go}{I (952) wifi:state: init \PYGZhy{}\PYGZgt{} auth (b0)}
\PYG{g+go}{I (952) wifi:state: auth \PYGZhy{}\PYGZgt{} assoc (0)}
\PYG{g+go}{I (962) wifi:state: assoc \PYGZhy{}\PYGZgt{} run (10)}
\PYG{g+go}{I (1002) wifi:connected with iPhone de Carlos, aid = 1, channel 6, BW20, bssid = 42:47:22:d6:7a:e9}
\PYG{g+go}{I (1012) wifi:security: WPA2\PYGZhy{}PSK, phy: bgn, rssi: \PYGZhy{}43}
\PYG{g+go}{I (1012) wifi:pm start, type: 1}

\PYG{g+go}{I (1102) wifi:AP\PYGZsq{}s beacon interval = 102400 us, DTIM period = 1}
\PYG{g+go}{I (1642) esp\PYGZus{}netif\PYGZus{}handlers: sta ip: 172.20.10.12, mask: 255.255.255.240, gw: 172.20.10.1}
\PYG{g+go}{I (1642) wifi station: got ip:172.20.10.12}
\PYG{g+go}{I (1642) wifi station: connected to ap SSID:iPhone de Carlos}
\end{sphinxVerbatim}

\sphinxAtStartPar
Como se puede observar, la información del firmware nos confirma que
el dispositivo se encuentra conectado al punto de acceso Wi\sphinxhyphen{}Fi
“iPhone de Carlos”. Adicionalmente, desde el propio punto Wi\sphinxhyphen{}Fi se puede
observar como en el momento de realizar el flash del firmware en el dispositivo,
se aumenta el número de dispositivos conectados a la red en 1.


\subsection{Fallo en la conexión con el agente de ROS 2}
\label{\detokenize{Anexos:fallo-en-la-conexion-con-el-agente-de-ros-2}}
\sphinxAtStartPar
Una vez establecida la conexión Wi\sphinxhyphen{}Fi, se trató de suscribirse al
topic en el que debía de estar publicando mensajes el cliente ya
conectado a la red. Tras ejecutar el comando:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{n}{ros2} \PYG{n}{topic} \PYG{n+nb}{list}
\end{sphinxVerbatim}

\sphinxAtStartPar
Se obtuvo la siguiente salida.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
carlos@carlos\PYGZhy{}UX430UA:\PYGZti{}/microros\PYGZus{}ws\PYGZdl{} ros2 topic list
/parameter\PYGZus{}events
/rosout
carlos@carlos\PYGZhy{}UX430UA:\PYGZti{}/microros\PYGZus{}ws\PYGZdl{}
\end{sphinxVerbatim}

\sphinxAtStartPar
En el terminal solo se observan los topic de ROS 2 por defecto,
y no se muestra el topic por el cual debería de estar publicando
mensajes la placa.

\sphinxAtStartPar
En primer lugar, se comprobó si la placa funcionaba correctamente.
Para ello se siguieron los  siguientes tutoriales para el testeo de
la placa en “Visual Studio Code”:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/install.md}

\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/basic\_use.md}

\end{itemize}

\sphinxAtStartPar
Tras la instalación y la prueba de un proyecto básico en la placa,
se confirmó el correcto funcionamiento de la misma.

\sphinxAtStartPar
Una vez descartado el posible error de funcionamiento de la placa,
se comprobó si el cliente establecía conexión  con el agente de mico\sphinxhyphen{}ROS
y si existía intercambio de información. En primer lugar, se utilizó un
agente de Docker para depurar el problema. Esto es una capa de software
de adicional que proporciona abstracción y la virtualización de
aplicaciones. De este modo, era posible probar la aplicación del cliente
en un espacio que no fuera ROS 2.

\sphinxAtStartPar
El siguiente comando ejecuta un agente en Docker.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
docker run \PYGZhy{}it \PYGZhy{}\PYGZhy{}rm \PYGZhy{}\PYGZhy{}net\PYG{o}{=}host microros/micro\PYGZhy{}ros\PYGZhy{}agent:foxy udp4 \PYGZhy{}\PYGZhy{}port \PYG{l+m}{8888} \PYGZhy{}v6
\end{sphinxVerbatim}

\sphinxAtStartPar
En otro terminal se ejecuta el siguiente comando para entrar en
la imagen del Docker:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
docker run \PYGZhy{}it osrf/ros:eloquent\PYGZhy{}desktop
\end{sphinxVerbatim}

\sphinxAtStartPar
Se descargará una imagen más nueva del Docker. Una vez inicializada
y con el agente Docker activo se comprueba si el topic es visible de
nuevo con el comando “ros2 topic list”. Se observa la siguiente salida:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{root@a4032df86129:/\PYGZsh{}} ros2 topic list
\PYG{g+go}{/freertos\PYGZus{}int32\PYGZus{}publisher}
\PYG{g+go}{/parameter\PYGZus{}events}
\PYG{g+go}{/rosout}
\end{sphinxVerbatim}

\sphinxAtStartPar
Como se puede observar, utilizando el Docker sí que se reconoce el topic
de la aplicación de FreeRTOS que se había instalado en la placa.

\sphinxAtStartPar
De este modo, fue posible deducir que el problema residía en la conexión
del agente de micro\sphinxhyphen{}ROS con el espacio de ROS 2. Se utilizó el siguiente
comando para ejecutar un agente de micro\sphinxhyphen{}ROS que mostrara información sobre
la conexión:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
ros2 run micro\PYGZus{}ros\PYGZus{}agent micro\PYGZus{}ros\PYGZus{}agent udp4 \PYGZhy{}\PYGZhy{}port  \PYG{l+m}{8888} \PYGZhy{}v6
\end{sphinxVerbatim}

\sphinxAtStartPar
En el agente se observa la siguiente salida:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
\PYG{g+gp}{carlos@carlos\PYGZhy{}UX430UA:\PYGZti{}/microros\PYGZus{}ws\PYGZdl{}} ros2 run micro\PYGZus{}ros\PYGZus{}agent micro\PYGZus{}ros\PYGZus{}agent udp4 \PYGZhy{}\PYGZhy{}port \PYG{l+m}{8888} \PYGZhy{}v6

\PYG{g+go}{[1633603125.726950] info     | UDPv4AgentLinux.cpp | init                     | running...             | port: 8888}

\PYG{g+go}{[1633603125.727267] info     | Root.cpp           | set\PYGZus{}verbose\PYGZus{}level        | logger setup           | verbose\PYGZus{}level: 6}

\PYG{g+go}{[1633603131.602949] debug    | UDPv4AgentLinux.cpp | recv\PYGZus{}message             | [==\PYGZgt{}\PYGZgt{} UDP \PYGZlt{}\PYGZlt{}==]        | client\PYGZus{}key: 0x00000000, len: 24, data:}
\PYG{g+go}{0000: 80 00 00 00 00 01 10 00 58 52 43 45 01 00 01 0F 1E A5 3D F9 81 00 FC 01}

\PYG{g+go}{[1633603131.603248] info     | Root.cpp           | create\PYGZus{}client            | create                 | client\PYGZus{}key: 0x1EA53DF9, session\PYGZus{}id: 0x81}

\PYG{g+go}{[1633603131.603400] info     | SessionManager.hpp | establish\PYGZus{}session        | session established    | client\PYGZus{}key: 0x1EA53DF9, address: 172.20.10.12:26313}

\PYG{g+go}{[1633603131.603645] debug    | UDPv4AgentLinux.cpp | send\PYGZus{}message             | [** \PYGZlt{}\PYGZlt{}UDP\PYGZgt{}\PYGZgt{} **]        | client\PYGZus{}key: 0x1EA53DF9, len: 19, data:}
\PYG{g+go}{0000: 81 00 00 00 04 01 0B 00 00 00 58 52 43 45 01 00 01 0F 00}

\PYG{g+go}{[1633603131.934983] info     | ProxyClient.cpp    | create\PYGZus{}participant       | participant created    | client\PYGZus{}key: 0x1EA53DF9, participant\PYGZus{}id: 0x000(1)}
\PYG{g+go}{0000: 81 80 00 00 05 01 06 00 00 0A 00 01 00 00}

\PYG{g+go}{[1633603132.191877] info     | ProxyClient.cpp    | create\PYGZus{}topic             | topic created          | client\PYGZus{}key: 0x1EA53DF9, topic\PYGZus{}id: 0x000(2), participant\PYGZus{}id: 0x000(1)}

\PYG{g+go}{[1633603132.287776] info     | ProxyClient.cpp    | create\PYGZus{}publisher         | publisher created      | client\PYGZus{}key: 0x1EA53DF9, publisher\PYGZus{}id: 0x000(3), participant\PYGZus{}id: 0x000(1)}

\PYG{g+go}{[1633603132.350367] info     | ProxyClient.cpp    | create\PYGZus{}datawriter        | datawriter created     | client\PYGZus{}key: 0x1EA53DF9, datawriter\PYGZus{}id: 0x000(5), publisher\PYGZus{}id: 0x000(3)}

\PYG{g+go}{[1633603133.465362] debug    | DataWriter.cpp     | write                    | [** \PYGZlt{}\PYGZlt{}DDS\PYGZgt{}\PYGZgt{} **]        | client\PYGZus{}key: 0x00000000, len: 4, data: 0000: 00 00 00 00}
\end{sphinxVerbatim}

\sphinxAtStartPar
La información más relevante reside en comprobar que el agente y el cliente
establecen una conexión y, aun más importante, que el agente de micro\sphinxhyphen{}ROS
publica los mensajes en el DDS. De este modo era complicado averiguar el hecho
de que, publicándose mensajes en la red de ROS 2, estos no eran reconocidos
desde la computadora. Se investigó este fallo a través de fuentes externas
%
\begin{footnote}[2]\sphinxAtStartFootnote
micro\sphinxhyphen{}ROS. No communication between micro\sphinxhyphen{}ROS and ROS2. URL: \sphinxurl{(https://github.com/micro-ROS/micro\_ros\_arduino/issues/7)}.
%
\end{footnote} y se averiguó que
el problema residía en el dominio de ROS escogido previamente.

\sphinxAtStartPar
Este se puede escoger a través de una variable del entorno denominada
“ROS\_DOMAIN\_ID”. En uno de los tutoriales realizados para el aprendizaje
del manejo de ROS 2, era necesario establecer esta variable en el
fichero .bashrc. Sin embargo, en las aplicaciones que ofrecen los RTOS,
este no es el dominio empleado, por lo cuál no es posible observar los
mensajes que se publican en el espacio DDS. Una vez suprimida esta línea
de código en el fichero .bashrc, se volvió a ejecutar todo el proceso
(flasheo del firmware y creación del agente). Finalmente, tras conectar
el cliente con el agente ya era posible observar tanto los nodos como los
topic a los que estaba conectada la placa.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\footnotesize]
carlos@carlos\PYGZhy{}UX430UA:\PYGZti{}/microros\PYGZus{}ws\PYGZdl{} ros2 topic list
/freertos\PYGZus{}int32\PYGZus{}publisher
/parameter\PYGZus{}events
/rosout
carlos@carlos\PYGZhy{}UX430UA:\PYGZti{}/microros\PYGZus{}ws\PYGZdl{} ros2 node list
/freertos\PYGZus{}int32\PYGZus{}publisher
\end{sphinxVerbatim}

\sphinxAtStartPar


\renewcommand{\listtablename}{Índice de tablas}
\listoffigures

\begin{sphinxthebibliography}{10}
\bibitem[1]{marco_teorico_y_estado_del_arte:id24}
\sphinxAtStartPar
Khan Accademy. User datagram protocol. URL: \sphinxurl{https://es.khanacademy.org/computing/ap-computer-science-principles/the-internet/x2d2f703b37b450a3:transporting-packets/a/user-datagram-protocol-udp\#:~:text=El\%20Protocolo\%20de\%20datagrama\%20de,o\%20llegan\%20fuera\%20de\%20orden.}
\bibitem[2]{marco_teorico_y_estado_del_arte:id21}
\sphinxAtStartPar
ROS2 Design. Ros middleware interface. URL: \sphinxurl{https://design.ros2.org/articles/ros\_middleware\_interface.html}.
\bibitem[3]{marco_teorico_y_estado_del_arte:id31}
\sphinxAtStartPar
Digi\sphinxhyphen{}Key. Espressif Systems. URL: \sphinxurl{https://www.digikey.es/es/supplier-centers/espressif-systems}.
\bibitem[4]{marco_teorico_y_estado_del_arte:id28}
\sphinxAtStartPar
Digi\sphinxhyphen{}Key. How to select the right RTOS and Microcontroller Platform for the IoT. URL: \sphinxurl{https://www.digikey.com/en/articles/how-to-select-the-right-rtos-and-microcontroller-platform-for-the-iot}.
\bibitem[5]{marco_teorico_y_estado_del_arte:id25}
\sphinxAtStartPar
Digi\sphinxhyphen{}Key. Real time operating system (RTOS) and their applications. URL: \sphinxurl{https://www.digikey.es/es/articles/real-time-operating-systems-and-their-applications}.
\bibitem[6]{marco_teorico_y_estado_del_arte:id32}
\sphinxAtStartPar
Digi\sphinxhyphen{}Key. ESP32\sphinxhyphen{}DevKitC. URL: \sphinxurl{https://www.espressif.com/en/products/devkits/esp32-devkitc}.
\bibitem[7]{marco_teorico_y_estado_del_arte:id33}
\sphinxAtStartPar
Digi\sphinxhyphen{}Key. ESP32­WROOM­32 Datasheet. URL: \sphinxurl{https://www.espressif.com/sites/default/files/documentation/esp32-wroom-32\_datasheet\_en.pdf}.
\bibitem[8]{marco_teorico_y_estado_del_arte:id34}
\sphinxAtStartPar
Digi\sphinxhyphen{}Key. ESP32­ Get Started. URL: \sphinxurl{https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html\#what-you-need}.
\bibitem[9]{marco_teorico_y_estado_del_arte:id23}
\sphinxAtStartPar
ePRoxima. ePRoxima fast DDS. URL: \sphinxurl{https://www.eprosima.com/index.php/products-all/eprosima-fast-dds}.
\bibitem[10]{marco_teorico_y_estado_del_arte:id8}
\sphinxAtStartPar
K. Erciyes. \sphinxstyleemphasis{Distributed Real\sphinxhyphen{}Time Systems}. Springer, 2019.
\bibitem[11]{marco_teorico_y_estado_del_arte:id17}
\sphinxAtStartPar
Fiware. Imicro\sphinxhyphen{}ros puts the Robot Operating System on Microcontroller. URL: \sphinxurl{https://www.youtube.com/watch?v=slMhPRnBVwM}.
\bibitem[12]{marco_teorico_y_estado_del_arte:id20}
\sphinxAtStartPar
Fiware. Micro\sphinxhyphen{}ROS client library. URL: \sphinxurl{https://www.fiware.org/2020/06/02/two-layered-api-introducing-the-micro-ros-client-library/}.
\bibitem[13]{marco_teorico_y_estado_del_arte:id43}
\sphinxAtStartPar
Linux Foundation. Cyclictest. URL: \sphinxurl{https://wiki.linuxfoundation.org/realtime/documentation/howto/tools/cyclictest/start}.
\bibitem[14]{marco_teorico_y_estado_del_arte:id19}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. First Linux application. URL: \sphinxurl{https://micro.ros.org/docs/tutorials/core/first\_application\_linux/}.
\bibitem[15]{marco_teorico_y_estado_del_arte:id27}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. First micro\sphinxhyphen{}ROS application on a RTOS. URL: \sphinxurl{https://micro.ros.org/docs/tutorials/core/first\_application\_rtos/}.
\bibitem[16]{marco_teorico_y_estado_del_arte:id35}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. First micro\sphinxhyphen{}ROS Application on Linux. URL: \sphinxurl{https://micro.ros.org/docs/tutorials/core/first\_application\_linux/}.
\bibitem[17]{marco_teorico_y_estado_del_arte:id47}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. Microsoft Azure RTOS. URL: \sphinxurl{https://micro.ros.org/blog/2021/09/08/MicrosoftAzureRTOS/}.
\bibitem[18]{marco_teorico_y_estado_del_arte:id30}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. Supported Hardware. URL: \sphinxurl{https://micro.ros.org/docs/overview/hardware/}.
\bibitem[19]{marco_teorico_y_estado_del_arte:id26}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. Why a real time operating system. URL: \sphinxurl{https://micro.ros.org/docs/concepts/rtos/}.
\bibitem[20]{marco_teorico_y_estado_del_arte:id29}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. FreeRTOS. URL: \sphinxurl{https://micro.ros.org/docs/overview/rtos/\#freertos}.
\bibitem[21]{marco_teorico_y_estado_del_arte:id18}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. Micro\sphinxhyphen{}ROS features. URL: \sphinxurl{https://micro.ros.org/docs/overview/features/}.
\bibitem[22]{marco_teorico_y_estado_del_arte:id46}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. Micro\sphinxhyphen{}ROS on Arduino. URL: \sphinxurl{https://micro.ros.org/blog/2020/11/24/Arduino/}.
\bibitem[23]{marco_teorico_y_estado_del_arte:id42}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. ROSCon2018. URL: \sphinxurl{https://micro.ros.org/blog/2018/09/30/roscon/}.
\bibitem[24]{marco_teorico_y_estado_del_arte:id45}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. XRCE\_DDS 1.20 release. URL: \sphinxurl{https://micro.ros.org/blog/2020/05/12/xrce-dds\_120\_release/}.
\bibitem[25]{marco_teorico_y_estado_del_arte:id44}
\sphinxAtStartPar
micro\sphinxhyphen{}ROS. micro\sphinxhyphen{}ROS NuttX v0.0.2\sphinxhyphen{}alpha and Apps v0.0.3 release. URL: \sphinxurl{https://micro.ros.org/blog/2019/06/03/NuttX\_micro-ROS-v0.0.2\_relase/}.
\bibitem[26]{marco_teorico_y_estado_del_arte:id11}
\sphinxAtStartPar
Openwebinars. Qué es ROS. URL: \sphinxurl{https://openwebinars.net/blog/que-es-ros}.
\bibitem[27]{marco_teorico_y_estado_del_arte:id12}
\sphinxAtStartPar
ROS. History. URL: \sphinxurl{https://www.ros.org/history/}.
\bibitem[28]{marco_teorico_y_estado_del_arte:id15}
\sphinxAtStartPar
ROS. Installation. URL: \sphinxurl{https://docs.ros.org/en/foxy/Installation.html}.
\bibitem[29]{marco_teorico_y_estado_del_arte:id13}
\sphinxAtStartPar
ROS. Rolling. URL: \sphinxurl{https://docs.ros.org/en/rolling/}.
\bibitem[30]{marco_teorico_y_estado_del_arte:id14}
\sphinxAtStartPar
ROS. Tutorial. URL: \sphinxurl{https://docs.ros.org/en/foxy/Tutorials.html}.
\bibitem[31]{marco_teorico_y_estado_del_arte:id16}
\sphinxAtStartPar
ROS. Ubuntu installation. URL: \sphinxurl{https://docs.ros.org/en/foxy/Installation/Ubuntu-Install-Debians.html}.
\bibitem[32]{marco_teorico_y_estado_del_arte:id48}
\sphinxAtStartPar
RosCon. ROS World 2021. URL: \sphinxurl{https://roscon.ros.org/world/2021/}.
\bibitem[33]{marco_teorico_y_estado_del_arte:id36}
\sphinxAtStartPar
Sameer Tuteja. Connect ESP32 to ROS2 Foxy. URL: \sphinxurl{https://link.medium.com/JFof42RUwib}.
\bibitem[34]{marco_teorico_y_estado_del_arte:id22}
\sphinxAtStartPar
Wikipedia. Data distribution service. URL: \sphinxurl{https://es.wikipedia.org/wiki/Data\_Distribution\_Service}.
\bibitem[35]{marco_teorico_y_estado_del_arte:id41}
\sphinxAtStartPar
Wikipedia. Latency. URL: \sphinxurl{https://en.wikipedia.org/wiki/Latency\_(engineering)}.
\bibitem[36]{marco_teorico_y_estado_del_arte:id9}
\sphinxAtStartPar
Wikipedia. Sistema de tiempo real. URL: \sphinxurl{https://es.wikipedia.org/wiki/Sistema\_de\_tiempo\_real}.
\bibitem[37]{marco_teorico_y_estado_del_arte:id37}
\sphinxAtStartPar
Wikipedia. Sistema operativo de tiempo real. URL: \sphinxurl{https://es.wikipedia.org/wiki/Sistema\_operativo\_de\_tiempo\_real}.
\bibitem[38]{marco_teorico_y_estado_del_arte:id10}
\sphinxAtStartPar
Wikipedia. Robot Operating System. URL: \sphinxurl{https://es.wikipedia.org/wiki/Robot\_Operating\_System}.
\end{sphinxthebibliography}

\newpage
\thispagestyle{plain}
\null

\renewcommand{\indexname}{Índice}
\printindex
\end{document}